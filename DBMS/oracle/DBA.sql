SELECT * FROM DICT;
--오라클db에 대한 정보를 가지고 있는 테이블 : DATA DICTIONARY라고 함.
SELECT * FROM DICTIONARY;
--현재 DB에 등록된 사용자계정 정보보기
SELECT * FROM DBA_USERS;

-- 계정은 관리자 계정, 사용자 계정
-- 관리자계정 : 사용자 계정을 등록, 권한부여 하고, 전체 생성된 TABLE를 관리하는 역할 -> DBBASE를 전체적으로 관리
-- SYSTEM : 일반관리자 데이터 베이스자체를 생성, 삭제할 수 없음
-- SYS : 슈퍼관리자 데이터베이스 생성, 삭제, DATADICTIONARY 소유자 최고 관리자!

-- 기본적으로 오라클 DATA BASE를 이용하기 위해선 사용자 계정이 필요함.
-- 사용자 계정만들기, 계정 생성 후 이용권한부여
-- 사용자 계정은 SYSTEM, SYS AS SYSDBA 계정으로 명령어를 써야함.
-- CREATE USER 유저명 IDENTIFIED BY 비밀번호;
CREATE USER KH IDENTIFIED BY KH;
SELECT * FROM DBA_USERS;
-- 사용자계정은 CREATE로 생성한다고 해서 무조건 DB이용이 가능한것이 아님
-- 이용할 수 있는 권한을 SYSTEM/SYS계정이 부여해줘야함.
-- GRANT 권한명(ROLE) TO 사용자계정명;
-- RESOURCE, CONNECT권한(ROLE)을 부여한다.
GRANT RESOURCE, CONNECT TO KH;

-- test계정 생성 후 접속 하는것 
CREATE USER TEST IDENTIFIED BY TEST;
--RESOURCE, CONNECT 
-- -> RESOURCE 테이블을 생성 조작할 수 있는 권한
-- -> CONNECT 할당된 영역에 접속할 수 있는 권한
GRANT RESOURCE, CONNECT TO TEST;

-- KH계정 정보 확인하기
SELECT * FROM TAB; --계정이 가지고 있는 전체 테이블을 조회

-- 생성된 KH계정의 테이블확인해보자
SELECT * FROM DEPARTMENT;
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;
SELECT * FROM LOCATION;
SELECT * FROM SAL_GRADE;
SELECT * FROM NATIONAL;

-- KH계정의 EMPLOYEE 테이블을 조회해보자.
-- 사번(EMP_ID),이름(EMP_NAME), 월급(SALARY) 조회
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 사원이름, 이메일, 부서코드, 직책코드 조회하기
SELECT EMP_NAME, EMAIL, DEPT_CODE,JOB_CODE
FROM EMPLOYEE;

-- EMPLOYEE테이블에 있는 전체 컬럼을 조회하세요!
SELECT EMP_ID, EMP_NAME, EMP_NO, EMAIL, 
       PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, 
       SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN
FROM EMPLOYEE;
-- 테이블에 있는 컬럼을 전체 조회할때는 *을 사용하자
SELECT * 
FROM EMPLOYEE;


-- SELECT문은 단순히 조회뿐만 아니라 조회할때 산술연산처리도 가능
-- 단 산술연산은 숫자형타입을 계산
-- SELECT 컬럼명||리터럴값
SELECT 10*100
FROM DUAL; -- DUAL테이블은 오라클에서 기본제공하는 테이블로 간단한 테스트를 위한 테이블

-- SELECT문에서 산술연산할때는 컬럼명을 가져와 계산할 수도 있음
SELECT * 
FROM EMPLOYEE;

-- 사원의 연봉을 구하자
SELECT EMP_NAME, SALARY, SALARY*12
FROM EMPLOYEE;
-- 각 사원의 보너스를 구하자
SELECT EMP_NAME,SALARY, BONUS, SALARY*BONUS
FROM EMPLOYEE;

-- 컬럼값이 NULL인 ROW는 값이 없는것 쓰레기 -> 쓰레기 계산이 X

-- EMPLOYEE 테이블에서 사원명, 부서코드, 직책코드, 월급, 연봉, 보너스 포함한 연봉 조회하기
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, 
        SALARY, SALARY*12, (SALARY+(SALARY*BONUS))*12
FROM EMPLOYEE;

-- RESULTSET의 컬럼명 변경하기 컬럼명에 별칭부여하기
-- 컬럼명 AS 별칭명, 컬럼명 별칭, 
SELECT EMP_NAME, EMAIL, PHONE 
FROM EMPLOYEE;
SELECT EMP_NAME AS 사원명, EMAIL AS 이메일, PHONE 전화번호
FROM EMPLOYEE;

-- 별칭은 아무거나 다 사용이 가능한가? 띄어쓰기 특수기호
-- 특수기호, 첫글자숫자, 띄어쓰기를 사용할때는 ""으로 감싸야함.
-- ""로 감싼것은 문자열 리터럴이 아니다! 자바랑 다름!!!! -> 문자열리터럴 '' 으로 표시
SELECT EMP_NAME AS "사 원 명", EMAIL AS "^이메일",
     DEPT_CODE AS "1부서"
FROM EMPLOYEE;

-- SELECT절에서 문자열리터럴 사용하기
SELECT EMP_NAME,'님', SALARY,'원'
FROM EMPLOYEE;

-- 행에서 중복값을 제거하고 출력하기
-- DISTINCT : 중복된 행의 값을 한개만 출력
SELECT JOB_CODE
FROM EMPLOYEE;
SELECT DISTINCT JOB_CODE
FROM EMPLOYEE; -- JOB_CODE 출력할때 중복되는 값은 한개만 출력

SELECT JOB_CODE, DISTINCT DEPT_CODE
FROM EMOPLOYEE; -- DISTINCT는 SELECT문에서 한번 사용이 가능함. SELECT 맨 앞에.

SELECT DISTINCT JOB_CODE, DEPT_CODE
FROM EMPLOYEE;

-- 컬럼, 리터럴을 연결해보자.
-- || 연산자 : SELECT 에 작성된 컬럼||리터럴을 한개의 컬럼으로 합쳐주는 기능
SELECT EMP_NAME,'님',SALARY,'원'
FROM EMPLOYEE;

SELECT EMP_NAME||'님'||SALARY||'원',DEPT_CODE||JOB_CODE AS 부서직책
FROM EMPLOYEE;

-- SELECT 컬럼명, 컬럼명, 리터럴
-- FROM 테이블명
-- [WHERE 컬럼명 비교연산자(=,>=,<=,<,>!=) 컬럼명||리터럴 ] : 조건문 ROW(행)를 (DATA) 필터링해주는 문장!
-- 비교연산자
-- = : 동등비교(같니) 10=10, A=20
-- !=,<>,^= : 같지 않다 비교
-- >,<,<=,>= : 대소비교(숫자,날짜)
-- BETWEEN 숫자 AND 숫자 : 특정 범위에 값을 비교 // 1<=A&&A<=10;
-- LIKE /NOT LIKE : 특정패턴에 의해 값을 비교 * 부분일치여부
-- IN / NOT IN : 다중값의 포함여부를 비교 A IN 10,20,30
-- IS NULL / IS NOT NULL : NULL값에 대한 비교
-- 논리연산 : 진위여부를 확인하는 연산자 논리 && 논리 논리 || 논리
-- AND : 그리고 && 동일한 기능
-- OR : 또는 || 동일한 기능
-- NOT : 부정연산
SELECT EMP_NAME, SALARY
FROM EMPLOYEE;

-- EMPLOYEE 테이블에서 월급이 350만원 이상인 직원 조회 + 부서코드가 D5인 사원
-- 사원명, 부서코드, 급여
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= 3500000 AND DEPT_CODE='D5';

-- 부서코드가 D6이 아닌 사원의 전체 컬럼 조회하기
SELECT * 
FROM EMPLOYEE
--WHERE DEPT_CODE!='D6';
--WHERE DEPT_CODE<>'D6';
WHERE NOT DEPT_CODE='D6';

-- 직급코드가 J1아닌 사원들의 SAL_LEVEL을 중복없이 출력하세요
-- DISTINCT
SELECT DISTINCT SAL_LEVEL
FROM EMPLOYEE
WHERE DEPT_CODE!='J1';

-- 부서코드가 D5이거나 급여를 300만원이상 받는 사원
-- 사원명, 부서코드, 급여 
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5' OR SALARY >=3000000;

-- 사원의 급여가 200만원이상 400만원 이하인 사원의 사원명, 직책코드, 급여 조회
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >=2000000 AND SALARY <= 4000000;
-- 범위를 조회할때 BETWEEN AND 를 사용할 수 있다.
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY BETWEEN 2000000 AND 4000000;

-- 대소비교는 날짜할 수 있음 날짜는 문자열로 '년/월/일' -> '00/00/00'
-- EMPLOYEE 테이블에서 고용일(HIRE_DATE)이 00년01월01일 보다 빠른 사원을 조회
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE < '00/01/01'; --'일/월/년' ->'01/JAN/00'

-- LIKE : 패턴에 의해 데이터를 조회하는 기능
-- WHERE 컬럼명 LIKE '%리%터_럴_'
-- % : 글자가 0개 이상 아무문자나 다 허용 -> 
  --    '%강' -> 강으로 끝나는 데이터 / '%강%' 데이터에 강이 포함되어있는지
  --    가나다라마강 o , 강, 가나다강라나아라, 강하나둘셋
-- _ : 그 자리 아무문자나 한개
  --    '_강' -> 강으로 끝나는 두글자 
  --    '___'
  
-- EMPLOYEE 테이블에서 전씨 성을 가진 사원을 조회해라
-- 사원명, 급여
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
--WHERE EMP_NAME LIKE '전%';
WHERE EMP_NAME LIKE '전__%';

-- 사원명이 중간에 옹이들어가는 사원 이름 부서코드 조회
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE
--WHERE EMP_NAME LIKE '_옹%';
WHERE EMP_NAME LIKE '_옹_';

SELECT EMP_NAME, EMAIL
FROM EMPLOYEE;
-- EMPLOYEE테이블에서 이메일이 _앞의 글자가 3글자인 사원을 조회
-- 사원명, 이메일
SELECT EMP_NAME, EMAIL
FROM EMPLOYEE
--WHERE EMAIL LIKE '____%';
WHERE EMAIL LIKE '___#_%' ESCAPE '#';

-- 성이 이씨가 아닌 사원 조회하기 사원명, 이메일
SELECT EMP_NAME, EMAIL
FROM EMPLOYEE
--WHERE EMP_NAME NOT LIKE '이__%';
WHERE NOT EMP_NAME LIKE '이__%';

-- NULL을 비교해보자
-- BONUS가 NULL인 사원을 출력하기
-- 사원명, BONUS
SELECT EMP_NAME, BONUS
FROM EMPLOYEE
--WHERE BONUS = NULL;
WHERE BONUS = (null);
-- null을 비교하기 위해서는 오라클에서 제공하는 예약어를 사용
-- IS NULL /IS NOT NULL
SELECT EMP_NAME, BONUS
FROM EMPLOYEE
--WHERE BONUS IS NULL;
WHERE BONUS IS NOT NULL;

-- 다중값을 비교하기 
-- IN / NOT IN : 다중값을 한번에 동등비교
-- EMPLOYEE테이블에서 부서코드가 D5, D6인 사원 조회하기
-- 사원명, 부서코드 조회
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE
--WHERE DEPT_CODE = 'D5' OR DEPT_CODE='D6';
--WHERE DEPT_CODE IN('D5','D6'); -- 다중행 서브쿼리와 같이 사용
--WHERE DEPT_CODE IN (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '전%'); 
WHERE DEPT_CODE NOT IN('D5','D6');


-- 직책이 J2또는 J7인 사원중 급여가 200만원 보다 많은 사원을 조회하기
SELECT EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
--WHERE JOB_CODE='J7' OR JOB_CODE='J2' AND SALARY>=2000000;
WHERE (JOB_CODE='J7' OR JOB_CODE='J2') AND SALARY>=2000000;

--문자열 함수에 대해 알아보자
--LENGTH : 문자열||컬럼의 길이를 알려주는 기능
SELECT LENGTH('안녕하세요') FROM DUAL;
SELECT EMP_NAME, LENGTH(EMP_NAME), EMAIL, LENGTH(EMAIL) FROM EMPLOYEE;
--이메일의 글자수가 16이상인 사원출력
SELECT EMP_NAME, EMAIL, LENGTH(EMAIL) 
FROM EMPLOYEE
WHERE LENGTH(EMAIL)>=16;
--LENGTHB : 문자열||컬럼의 길이 BYTE단위로 출력
SELECT EMP_NAME, LENGTHB(EMP_NAME) FROM EMPLOYEE;
--오라클 EXPRESS버전에서 한글을 3BYTE / ENTERPRICE -> 2BYTE
SELECT LENGTHB('ASB') FROM EMPLOYEE;

-- INSTR
-- 찾는 문자열이 지정한 위치부터 지정한 횟수번째에 나타나는 위치 반환( 인덱스번호)
-- INSTR(문자열||컬럼 TARGET,문자열||컬럼 찾는문자,시작위치, 몇번째에서찾을건가)
SELECT INSTR('KH정보교육원','KH') FROM DUAL;--오라클은 0을 사용하지 않음, 시작 1
SELECT INSTR('KH정보교육원 KH수강생화이팅','KH',3) FROM DUAL;
SELECT INSTR('KH정보교육원 KH수강생화이팅 KH RCLASS힘내라','KH',3,2) FROM DUAL;
SELECT INSTR('KH정보교육원 KH수강생화이팅 KH RCLASS힘내라','KH',-1,2) FROM DUAL;

-- EMPLOYEE 테이블에서 EMAIL의 @의 위치를 구하세요
SELECT EMAIL,INSTR(EMAIL,'@') FROM EMPLOYEE;

-- LPAD/RPAD : 할당된 공간에서 빈공간의 왼,오른쪽을 특정문자로 채우는 기능
-- L/RPAD(문자열||컬럼, 공간의크기,문자)
SELECT LPAD('YOOBS',10,'*') FROM DUAL;
SELECT RPAD('YOOBS',20,'^^') FROM DUAL;
SELECT EMAIL, RPAD(EMAIL,16,'#') FROM EMPLOYEE;
SELECT LPAD('YOOBS',10) FROM DUAL; --DEFAULT값 공란

-- LTRIM/RTRIM : 문자열의 왼쪽, 오른쪽에 있는 공란, 지정문자를 제거
-- L/RTRIM(문자열||컬럼[,문자])
SELECT LTRIM('   병승   ') FROM DUAL;
SELECT RTRIM('    병승    ') FROM DUAL;
--SELECT * FROM EMPLOYEE WHERE EMP_NAME='병승';
SELECT LTRIM('000012345653','0') FROM DUAL;
SELECT LTRIM('0000110001100011','0') FROM DUAL;
SELECT LTRIM('0000110001100011','01') FROM DUAL;
--- 12314123092635123유병승에서 유병승만 남기세요
SELECT LTRIM('12314123092635123유병승','0123456789') FROM DUAL;
-- 1231912039184유병승102938124123714907493 유병승만 남기세요 힌트~ 반환있음
SELECT LTRIM(RTRIM('1231912039184유병승102938124123714907493','0123456789'),'0123456789') FROM DUAL;

-- TRIM : 양쪽, 옵션에 따라 왼쪽,오른쪽,양쪽의 특정 문자(1개)를 제거
-- TRIM(문자열||컬럼) -> 공백제거
-- TRIM(한개문자 FROM 문자열||컬럼) 양쪽에서 문자를 제거
-- TRIM(LEADING||TRAILING||BOTH 문자 FROM 문자열||컬럼) 
SELECT '    병승    ', TRIM('    병승    ') AS A FROM DUAL;
SELECT TRIM('   A   병승   B   ') FROM DUAL;
SELECT TRIM('Z' FROM 'ZZZAZZ병승ZZBZZ') FROM DUAL;--한글자만 가능
SELECT TRIM(LEADING FROM '     병승     ') AS A FROM DUAL;
SELECT TRIM(TRAILING FROM '    병승     ') AS A FROM DUAL;
SELECT TRIM(LEADING 'ㅋ' FROM 'ㅋㅋㅋㅋㅋ상현ㅋㅋㅋㅋㅋ') AS A FROM DUAL;

-- SUBSTR : 컬럼이나 문자열에서 지정한 위치부터 지정한 갯수만큼 잘라내는 함수
-- SUBSTR(문자열||컬럼, 시작위치[,길이]) 
SELECT SUBSTR('SHOWMETHEMONEY',5) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY',5,2) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY',-3,3) FROM DUAL;

SELECT EMP_NAME, SUBSTR(EMP_NO,1,6) FROM EMPLOYEE;
--여자사원출력하기
SELECT EMP_NAME, EMP_NO 
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1)=2;
SELECT SUBSTR(EMAIL,INSTR(EMAIL,'@')+1) FROM EMPLOYEE;

-- 영문자관련 대문자, 소문자, 첫글자만 대문자로
-- LOWER/UPPER/INITCAP
SELECT LOWER('Welcome to OralceWorld') FROM DUAL;
SELECT UPPER('Welcome to OralceWorld') FROM DUAL;
SELECT INITCAP('Welcome to OralceWorld') FROM DUAL;

SELECT EMAIL 
FROM EMPLOYEE
WHERE EMAIL LIKE LOWER('%KH%');

-- CONCAT : 연결연산을 하는 함수. == ||
-- CONCAT(문자열||컬럼,문자열||컬럼)
SELECT CONCAT('여러분',' 오라클 재미있나요?') FROM DUAL;
SELECT '여러분'||' 오라클 재미있나요?' FROM DUAL;
SELECT CONCAT(EMP_NAME,'님') FROM EMPLOYEE;

-- REPLACE : 특정문자을 변경하는것
-- REPLACE(타켓문자||컬럼,변경될 문자, 교체할 문구)
SELECT REPLACE('I LOVE MY LIFE','LOVE','HATE') FROM DUAL;
SELECT REPLACE(EMAIL,'kh.or.kr','bs.com') FROM EMPLOYEE;

-- REVERSE : 해당 문자열 꺼꾸로 만드는 기능 - 한글은 지원안함
SELECT REVERSE('ABC') FROM DUAL;
SELECT REVERSE(REVERSE('가나다')) FROM DUAL;

-- TRANSLATE : 매칭되어있는 값으로 출력
SELECT TRANSLATE('010-3644-6259','0123456789','영일이삼사오육칠팔구') FROM DUAL;


SELECT EMP_NAME, EMP_NO, REVERSE(EMP_NO) 
FROM EMPLOYEE;


-- 숫자처리함수
-- ABS : 절대값처리하는 함수
SELECT ABS(10), ABS(-10) FROM DUAL;
-- MOD : 나머지를 구하는 함수
-- MOD(숫자, 나눌값)
SELECT MOD(3,2) FROM DUAL;
SELECT MOD(SALARY,3) FROM EMPLOYEE;
SELECT * 
FROM EMPLOYEE
WHERE MOD(SALARY,3)=0;

-- ROUND : 소수점 반올리하는 기능
-- ROUND(소수점자리숫자[,자리수]) -> 소수점에서 반올림
SELECT ROUND(126.456),ROUND(126.543) FROM DUAL;
SELECT ROUND(126.456,1) FROM DUAL;
SELECT ROUND(126.456,-2) FROM DUAL;

-- FLOOR : 소수점자리를 버림
SELECT FLOOR(123.456) FROM DUAL;
SELECT FLOOR(1.456) FROM DUAL;

-- TRUNC : 버림(위치지정)
SELECT TRUNC(123.456),TRUNC(123.456,2), TRUNC(123.456,1) ,TRUNC(125.1234,-1) FROM DUAL;

-- CEIL : 무조건올림
SELECT CEIL(122.123), CEIL(122.123) FROM DUAL;

SELECT EMP_NAME, FLOOR(SALARY+(SALARY*BONUS)/3) FROM EMPLOYEE;

-- 날짜처리함수
-- SYSDATE : 시스템의 지금날짜를 출력
SELECT SYSDATE FROM DUAL;
SELECT SYSDATE, CURRENT_DATE, LOCALTIMESTAMP, CURRENT_TIMESTAMP 
FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE,'YYYY-MM-DD HH24:MI:SS')
FROM DUAL;

-- 날짜도 산술연산이 가능 +, - 
-- +/-는 일자를 계산.
SELECT SYSDATE-1 AS 어제 ,SYSDATE AS 오늘 ,SYSDATE+1 AS 내일
FROM DUAL;
-- 날짜끼리 계산 LONG타입의 숫자
SELECT SYSDATE - TO_DATE('01/02/24','YY/MM/DD') FROM DUAL;

--ADD_MONTHS : 개월수를 연산해주는 함수 개월수 더 해주는 함수
--ADD_MONTHS(날짜,더할 개월)
SELECT ADD_MONTHS(SYSDATE,3) FROM DUAL;

--EMPLOYEE테이블에서 입사 3개월 후 날짜를 구하세요
SELECT HIRE_DATE, ADD_MONTHS(HIRE_DATE,3) FROM EMPLOYEE;

-- 오늘부로 상현씨가 군대로 끌려감(재입대) 군복무기간 1년 6개월
-- 전역일자를 구하고, 전역까지 먹는 짬밥의 수를 구하세요 하루3끼로 계산
SELECT ADD_MONTHS(SYSDATE,18) AS 전역일, (ADD_MONTHS(SYSDATE,18)-SYSDATE)*3 AS 짬밥수
FROM DUAL;


-- MONTHS_BETWEEN : 개월수를 구하는 함수 
-- MONTHS_BETWEEN(D1, D2)
SELECT FLOOR(MONTHS_BETWEEN(SYSDATE, TO_DATE('21/07/10','RR/MM/DD')))
FROM DUAL;
-- EMPLOYEE테이블에서 사원의 근무개월수를 구하자
-- 이름, 부서, 직책 근무개월수 조회
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, FLOOR(MONTHS_BETWEEN(SYSDATE,HIRE_DATE))
FROM EMPLOYEE;


-- NEXT_DAY : 날짜에 입력받은 요일중 가장가까운 다음 요일을 출력
SELECT SYSDATE, NEXT_DAY(SYSDATE,'월요일') FROM DUAL;
SELECT NEXT_DAY(SYSDATE,'금') FROM DUAL;
SELECT NEXT_DAY(SYSDATE,'MON') FROM DUAL;
SELECT NEXT_DAY(SYSDATE,'MONDAY') FROM DUAL;
SELECT NEXT_DAY(SYSDATE,'FRIDAY') FROM DUAL;
-- 오라클 LOCALE 사용지역에 대한 언어설정
SELECT * FROM V$NLS_PARAMETERS;
ALTER SESSION SET NLS_LANGUAGE=KOREAN;

-- LAST_DAY :  그달의 마지막날을 출력
SELECT LAST_DAY(SYSDATE) FROM DUAL;

-- EXTRACT : 날짜의 년, 월, 일을 따로 출력할 수 있게 
-- EXTRACT(YEAR FROM 날짜) :  년만 출력
-- EXTRACT(MONTH FROM 날짜)  : 월만 출력
-- EXTRACT(DAY FROM 날짜) :  일만 출력
SELECT EXTRACT(YEAR FROM SYSDATE), EXTRACT(MONTH FROM SYSDATE), EXTRACT(DAY FROM SYSDATE)
FROM DUAL;
SELECT EXTRACT(HOUR FROM CAST(SYSDATE AS TIMESTAMP)) FROM DUAL;
SELECT EXTRACT(MINUTE FROM CAST(SYSDATE AS TIMESTAMP)) FROM DUAL;
SELECT EXTRACT(SECOND FROM CAST(SYSDATE AS TIMESTAMP)) FROM DUAL;
SELECT EXTRACT(HOUR FROM CAST(SYSDATE AS TIMESTAMP))||':'||EXTRACT(MINUTE FROM CAST(SYSDATE AS TIMESTAMP))
||':'||EXTRACT(SECOND FROM CAST(SYSDATE AS TIMESTAMP)) FROM DUAL;
--입사일이 90년대인 사원의 이름 부서 입사일 조회
SELECT EMP_NAME, DEPT_CODE, EXTRACT(YEAR FROM HIRE_DATE) 
FROM EMPLOYEE
WHERE EXTRACT(YEAR FROM HIRE_DATE) BETWEEN 1900 AND 1999;

-- 형변환 함수
-- 오라클에서 데이터를 저장하기 위한 TYPE을 가지고 있음
-- 숫자 : NUMBER -> 정수, 소수점 다 보관
-- 문자 : CHAR, VARCHAR2, NCHAR, NVARCHAR2 * VARCHAR2 권장.

--CREATE TABLE TEST(
--    NAME CHAR(10),
--    NAME2 VARCHAR2(10)
--)

-- 날짜 : DATE

-- 형변환함수
--TO_CHAR : DATE, NUMBER형 자료형을 CHARACTER형으로 변경하는것
SELECT TO_CHAR(SYSDATE,'YYYY/MM/DD DY HH24:MI:SS'),
   TO_CHAR(SYSDATE+1,'YY/MM/DD (DY)')
FROM DUAL;
-- NUMBER -> CHARACTER형으로 변경
SELECT 12345,
    TO_CHAR(912345,'999,999,999'),
    TO_CHAR(435123,'9,999'),
    TO_CHAR(8500000,'L999,999,999'),
    TO_CHAR(800,'$999,999,999'),
    TO_CHAR(912345,'000,000,000'),
    TO_CHAR(123456,'000,000'),
    TO_CHAR(80.5,'999,999.00'),
    TO_CHAR(100,'999,999.00')
FROM DUAL;

-- EMPLOYEE테이블에서 급여를 이쁘게 출력해보자
-- 사원명, 부서코드 월급(이쁘게)
SELECT  EMP_NAME, DEPT_CODE,
    TO_CHAR(SALARY,'L999,999,999,999')||'원'
FROM EMPLOYEE;    

-- TO_DATE : 숫자, 문자를 날짜로 변경하는 함수
SELECT TO_DATE('19960626','YYYYMMDD') FROM DUAL;
--'00/01/01' -> 자동형변환
SELECT TO_CHAR(TO_DATE('19981027 14:18:15','YYYYMMDD HH24:MI:SS'),'YYYY/MM/DD DY HH24:MI') FROM DUAL;
SELECT TO_DATE(960925,'YYMMDD') FROM DUAL;
-- 주석의 의미가
SELECT TO_DATE('000224','YYMMDD') 
FROM DUAL;

SELECT * FROM TAB WHERE TNAME='EMPLOYEE';
SELECT * --주석의 의미가 없어져요!
FROM KH.EMPLOYEE;


--SELECT RPAD('ABDC',10,'') FROM DUAL;

--TO_NUMBER : 문자형데이터를 숫자형데이터로 변환, 산술연산할때 사용
-- TO_NUMBER(문자||컬럼,형식)
SELECT '1,000,000'+'2,000,000' FROM DUAL;
SELECT TO_NUMBER('1,000,000','999,999,999') + TO_NUMBER('2,000,000','999,999,999')
FROM DUAL;
SELECT TO_NUMBER('123A','999') FROM DUAL;

-- NVL() : NULL값을 특정값(문자, 숫자)으로 대체 시켜주는 함수
-- NVL(컬럼, 대체값)
SELECT EMP_NAME, SALARY,BONUS, (SALARY+(SALARY*NVL(BONUS,0)))*12 
FROM EMPLOYEE;
SELECT EMP_NAME, SALARY, BONUS, NVL(BONUS,0)
FROM EMPLOYEE;

-- DEPT_CODE가 NULL인 사원은 인턴으로 출력하기
-- 사원명, DEPT_CODE 
SELECT EMP_NAME, NVL(DEPT_CODE,'인턴')
FROM EMPLOYEE
WHERE DEPT_CODE IS NULL;

-- NVL2() : NULL이면, NULL이 아니면 두가지를 다 대체하는 함수
SELECT EMP_NAME, BONUS, NVL2(BONUS,'있다','없다')
FROM EMPLOYEE;

--GREATEST / LEAST : 최대/최소구하기
SELECT GREATEST(1,2,3,4,5), GREATEST('가','나','다') FROM DUAL;
SELECT LEAST(1,2,3,4,5), LEAST('가','나','다') FROM DUAL;
SELECT GREATEST(1,2,3,4,5)
FROM DUAL;

-- DECODE : 선택함수 * 자바의 SWITCH문과 비슷한 구문
-- DECODE(표현식,조건,결과,조건1,결과,조건2,결과.....)
--EMPLOYEE 테이블에 성별을 추가하자.
SELECT EMP_NAME, EMP_NO,
        DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여','3','남','4','여') AS 성별
FROM EMPLOYEE;
SELECT EMP_NAME, JOB_CODE,
    DECODE(JOB_CODE,'J1','대표','J2','부사장','기타')
FROM EMPLOYEE;

-- CASE문 : DECODE와 활용이 비슷함.
-- CASE 
--      WHEN 조건1 THEN 결과
--      WHEN 조건2 THEN 결과2
--      WHEN 조건3 THEN 결과3
--      ELSE 결과
-- END

SELECT EMP_NAME, EMP_NO,
    CASE 
        WHEN SUBSTR(EMP_NO,8,1)=1 THEN '남'
        --WHEN SUBSTR(EMP_NO,8,1)=2 THEN '여'
        ELSE '여'
    END AS 성별,
    CASE 
        WHEN SALARY > 4000000 THEN '고액월급자'
        WHEN SALARY > 3000000 THEN '중간월급자'
        ELSE '월급자'
    END
FROM EMPLOYEE;

SELECT EMP_NAME,
    CASE SUBSTR(EMP_NO,8,1)
        WHEN '1' THEN '남'
        WHEN '3' THEN '남'
        ELSE '여'        
    END
FROM EMPLOYEE;

--사원 테이블에서 현재나이를 구해보세요
-- 사원번호, 사원명, EMP_NO, 나이

SELECT EMP_ID, EMP_NAME, EMP_NO,
    EXTRACT(YEAR FROM SYSDATE)- EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,2),'YY'))+1 AS "나이(YY)",
    EXTRACT(YEAR FROM SYSDATE)- EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,2),'RR'))+1 AS "나이(RR)",
    TO_NUMBER(EXTRACT(YEAR FROM SYSDATE)) - 
    (TO_NUMBER(SUBSTR(EMP_NO,1,2))+CASE WHEN SUBSTR(EMP_NO,8,1) IN('1','2') THEN 1900 ELSE 2000 END)+1 AS 나이
FROM EMPLOYEE;

insert into KH.EMPLOYEE  
values ('250','고두밋','470808-2123341','go_dm@kh.or.kr',null,'D2','J2','S5',4480000,null,null,to_date('94/01/20','RR/MM/DD'),null,'N');
commit;


-- SELECT 문 순서를 정렬하는 예약어 
-- ORDER BY 

-- SELECT 컬럼,.... -> COLUMN필터링
-- FROM 테이블
-- [WHERE 비교연산, 논리연산....] -> ROW필터링
-- [ORDER BY 컬럼명,..] -> 특정 컬럼을 기준으로 순서 정렬하는 것 (오름차순, 내림차순)

-- ASC : 오름차순정렬(작은수 -> 큰수, 사전순 A -> Z, 가 -> 하, 날짜 빠른순 NULL 맨아래)
-- DESC : 내림차순정렬 (큰수 -> 작은수, 사전역순 Z -> Z, 하 -> 가, 날짜 늦은순  NULL 맨 위로)

SELECT EMP_NAME, SALARY, BONUS, HIRE_DATE
FROM EMPLOYEE
--ORDER BY EMP_NAME ASC;
--ORDER BY SALARY DESC;
--ORDER BY BONUS;--DEFAULT값은 ASC(오름차순정렬)
--ORDER BY BONUS DESC;
--ORDER BY HIRE_DATE DESC;
--ORDER BY SALARY DESC, EMP_NAME;
ORDER BY 1;

SELECT EMP_NAME, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') 
FROM EMPLOYEE
ORDER BY 2;

--별칭이 사용이 가능할까?
SELECT EMP_NAME AS 사원 
FROM EMPLOYEE
WHERE  EMP_NAME LIKE '%하%'
ORDER BY 사원;

-- 그룹함수
-- RESULTSET이 한행만 나오는 함수 -> 집계(합계, 평균, 갯수 최대값, 최소값)
-- SUM : 컬럼의 총합 (NUMBER형)
-- 월급의 총합을 구하시오
SELECT SALARY FROM EMPLOYEE;
SELECT SUM(SALARY) 
FROM EMPLOYEE
WHERE DEPT_CODE='D6';

SELECT EMP_NAME, SUM(SALARY) 
FROM EMPLOYEE;

-- AVG : 평균 
SELECT TO_CHAR(FLOOR(AVG(SALARY)),'L999,999,999')
FROM EMPLOYEE
WHERE DEPT_CODE='D5';

-- COUNT : ROW갯수를 알려주는 함수
SELECT COUNT(*) 
FROM EMPLOYEE;

--사원중 직책이  J6인 사원의 수는?
SELECT COUNT(*) 
FROM EMPLOYEE
WHERE JOB_CODE='J6';

SELECT COUNT(BONUS)
FROM EMPLOYEE; -- 컬럼에 있는 NULL값을 제외시키고 숫자를 셈

SELECT COUNT(*), COUNT(BONUS), SUM(SALARY), AVG(SALARY)
FROM EMPLOYEE;

-- MAX / MIN
SELECT MAX(SALARY), MIN(SALARY)
FROM EMPLOYEE;

-- 부서가 D5,D6,D7인 사원중 가장 월급이 많은 사람의 월급은
SELECT MAX(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IN('D5','D6','D7');

-- 부서별 가장 높은 급여는?
SELECT DEPT_CODE, MAX(SALARY) 
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY DEPT_CODE;

-- 부서별 급여 평균
SELECT EMP_NAME, DEPT_CODE, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE;
-- 직책별 합계
SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY JOB_CODE
ORDER BY 1;

-- 직책별 인원수 구하기
SELECT JOB_CODE, COUNT(JOB_CODE)
FROM EMPLOYEE
GROUP BY JOB_CODE;

--부서별 보너스를 받는 사원의 수
SELECT DEPT_CODE, COUNT(BONUS)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
WHERE BONUS IS NOT NULL
GROUP BY DEPT_CODE;

-- GROUP BY 절에는 한개이상의 컬럼을 사용할 수 있다.
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE,JOB_CODE
ORDER BY 1,2;

-- 부서별 성별 인원수 구하기
SELECT DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별,
    COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여')
ORDER BY 1;

-- 부서별 급여 평균이 300백만원 이상인 부서들에 대해 부서명, 부서평균을 조회하세요
SELECT DEPT_CODE, FLOOR(AVG(SALARY))
FROM EMPLOYEE
--WHERE FLOOR(AVG(SALARY))>3000000
GROUP BY DEPT_CODE
HAVING FLOOR(AVG(SALARY))>3000000;

-- GROUP 함수를 조건으로 사용할 경우에는 HAVING을 이용한다.

--부서별 사원수가 3명 이상인 부서 출력하기
SELECT DEPT_CODE, COUNT(*) 
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING COUNT(*) > 3;

-- 매니저가 관리하는 사원이 2명이상인 매니져아이디와 관리하는 사원수 출력하기
SELECT MANAGER_ID, COUNT(*) 
FROM EMPLOYEE
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
HAVING COUNT(*) >= 2;

-- 합계(SUM), ROW하고 같이 나오는 합계
-- GROUP별 합계, 총합계까지 같이 출력하게 해보자
-- ROLLUP, CUBE 
SELECT DEPT_CODE, COUNT(*) 
FROM EMPLOYEE 
WHERE DEPT_CODE IS NOT NULL
--GROUP BY DEPT_CODE;
--GROUP BY ROLLUP(DEPT_CODE);
GROUP BY CUBE(DEPT_CODE);

SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
--GROUP BY ROLLUP(DEPT_CODE);
GROUP BY CUBE(DEPT_CODE);

-- ROLLUP과 CUBE는 다른 결과를 반환하게 됨. -> 2개이상의 컬럼을 GROUP BY 했을때
-- ROLLUP : 두개의 컬럼 중 왼쪽에 선언된 컬럼을 기준으로 합계 총계를 구하고
-- CUBE : 두개의 컬럼 모두를 기준으로 그룹함수를 계산을 하고 합계 총계를 구함
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
--GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
--GROUP BY ROLLUP(JOB_CODE,DEPT_CODE)
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1,2;

-- GROUPING
-- GROUP BY 에 의해 산출된 ROW인 경우에는 0을 반환, 
-- ROLLUP, CUBE를 이용해서 산출된 ROW는 1을 반환.
SELECT DEPT_CODE, GROUPING(DEPT_CODE), JOB_CODE, GROUPING(JOB_CODE),  COUNT(*) 
FROM EMPLOYEE 
WHERE DEPT_CODE IS NOT NULL
--GROUP BY DEPT_CODE
--GROUP BY ROLLUP(DEPT_CODE, JOB_CODE);
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1,2;


SELECT CASE
            WHEN GROUPING(DEPT_CODE)=0 AND GROUPING(JOB_CODE)=1 THEN '부서별 합계'
            WHEN GROUPING(DEPT_CODE)=1 AND GROUPING(JOB_CODE)=0 THEN '직책별 합계'
            WHEN GROUPING(DEPT_CODE)=1 AND GROUPING(JOB_CODE)=1 THEN '총합계'
            ELSE '그룹합계'
        END AS 구분,DEPT_CODE, JOB_CODE,
        SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1;
-------------------------
-- 집합연산자 : 여러개의 SELECT문을 합치거나 중복값을 제거하거나... 이런 연산하는것
-- 집합연산자를 사용할때는 조건 : 첫번째 SELECT문의 컬럼의 갯수와 동일, 컬럼의 타입도 동일해야 함. 
-- UNION : 여러개의 SELECT문을 합치는것 단 중복값 한개만 포함.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
UNION
SELECT DEPT_ID, DEPT_TITLE, LOCATION_ID, 0
FROM DEPARTMENT
UNION 
SELECT JOB_CODE, JOB_NAME, NULL, 0
FROM JOB;
DESC JOB;

DESC DEPARTMENT;--테이블에 정의된 컬럼확인하는 명령어

-- UNION중복값은 한개만 표현
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE JOB_CODE='J6'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE MANAGER_ID IS NOT NULL;

-- INTERSECT : 교집합, 중복되는값
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--MINUS : 중복값을 제외한 나머지
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY GROUPING SETS((DEPT_CODE, JOB_CODE, MANAGER_ID),
                        (DEPT_CODE, MANAGER_ID),
                        (JOB_CODE, MANAGER_ID));

SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE, MANAGER_ID;
SELECT DEPT_CODE, MANAGER_ID, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE, MANAGER_ID;
SELECT JOB_CODE, MANAGER_ID, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY JOB_CODE, MANAGER_ID;

-------------------------------
--기본적인 조인 적용해보기
--오라클 조인이용하기
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE=DEPT_ID;

--ANSI 조인 이용이 JOIN 명시해야 함.
SELECT *
--FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID;--왜? 두명어디갔어? DEPT_CODE가 NULL인 사원이 사라짐
FROM EMPLOYEE RIGHT OUTER JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID;
SELECT COUNT(*) FROM EMPLOYEE;

-- JOIN 두가지의 종류
-- 1. EQUI JOIN : 테이블 연결할때 동등비교로 연결하는 것
-- INNER JOIN : 기준이 되는 컬럼에 NULL값 있는 ROW 생략하고 연결한다.
SELECT  E.*, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE E JOIN DEPARTMENT D ON DEPT_CODE=DEPT_ID
WHERE DEPT_TITLE='총무부';

-- EMPLOYEE 테이블 하고 JOB테이블을 JOIN해보자.
SELECT * 
--FROM EMPLOYEE E JOIN JOB J ON E.JOB_CODE=J.JOB_CODE;
-- 두테이블의 컬럼명이 일치하면 ON -> USING예약어를 사용할 수 있음
FROM EMPLOYEE JOIN JOB USING(JOB_CODE);

SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;

-- OUTER JOIN : 기준이되는 테이블은 모두 출력하고 매칭되는 값이 없으면 컬럼에 NULL값을 출력함
--   LEFT OUTER JOIN : 왼쪽 테이블 기준
--   RIGHT OUTER JOIN : 오른쪽 테이블 기준

-- 오라클전용문법 -> (+)
SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE=DEPT_ID(+);


-- CROSS JOIN : 카티션곱 -> 각 ROW전체를 연결하는것
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;

SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE CROSS JOIN DEPARTMENT
ORDER BY 1;

-- SELF JOIN : 
SELECT * FROM EMPLOYEE;
-- 각사원의 사원 이름 매니저 이름을 조회하세요 
SELECT E.EMP_NAME,NVL(M.EMP_NAME,'없음')
FROM EMPLOYEE E LEFT OUTER JOIN EMPLOYEE M ON E.MANAGER_ID=M.EMP_ID;

-- 다중 JOIN : 두개 이상의 테이블을 연결하는 것
-- 사원의 부서명, 직책명을 조회하는 sql문을 작성하자
-- 사원이름(employee), 부서명(department), 직책명(job)
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE 
    JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    JOIN JOB USING(JOB_CODE);
    
-- 사원명, 부서명, 근무하고 있는 지역(LOCAL_NAME)을 출력
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, JOB_NAME
FROM EMPLOYEE
    JOIN LOCATION ON LOCAL_CODE=LOCATION_ID
    JOIN DEPARTMENT ON DEPT_ID=DEPT_CODE
    JOIN JOB USING(JOB_CODE);

--OUTER INNER같이 사용할 수 있음
SELECT EMP_NAME, NVL(DEPT_TITLE,'인턴'), NVL(LOCATION_ID,'대기발령'), LOCAL_NAME, JOB_NAME
FROM EMPLOYEE
    LEFT JOIN DEPARTMENT ON DEPT_ID=DEPT_CODE
    LEFT JOIN LOCATION ON LOCAL_CODE=LOCATION_ID
    JOIN JOB USING(JOB_CODE)
WHERE DEPT_TITLE LIKE '%해외%' AND SALARY >3000000
ORDER BY 5;
    
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
       
-- 2. NON-EQUI JOIN : 대소비교, 범위, NULL값 등의 조건으로 연결하는 것. -> 많은 x
SELECT EMP_NAME, SALARY, SAL_GRADE.SAL_LEVEL
FROM EMPLOYEE JOIN SAL_GRADE ON SALARY BETWEEN MIN_SAL AND MAX_SAL;

SELECT * FROM SAL_GRADE;

-- 서브쿼리 
-- 하나의 SQL문(MAIN쿼리)안에 포함되어있는 또 다른 SQL문(서브쿼리)
-- 서브쿼리는 반드시 소괄호 () 묶어줘야한다.
-- 서브쿼리는 WHERE절에 사용시에 오른쪽에 위치함

-- 전지연 사원의 관리자 이름을 출력
SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME='전지연';
SELECT EMP_NAME FROM EMPLOYEE WHERE EMP_ID=214;

SELECT M.EMP_NAME 
FROM EMPLOYEE E JOIN EMPLOYEE M ON E.MANAGER_ID=M.EMP_ID
WHERE E.EMP_NAME='전지연';

SELECT EMP_NAME 
FROM EMPLOYEE
WHERE EMP_ID=(SELECT MANAGER_ID 
                FROM EMPLOYEE WHERE EMP_NAME='전지연');

-- 사원의 평균급여보다 많이 받는 사원을 조회하기
-- 사원명, 부서명, 직책명, 급여
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
FROM EMPLOYEE 
    JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    JOIN JOB USING(JOB_CODE)
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE);

--1. 단일행 서브쿼리 : 서브쿼리의 결과가 한개열, 한개 행을 의미함.
-- 윤은해 사원과 동일한 급여는 받고 있는 사원을 구하세요
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME='윤은해');
-- 사원의 최대급여를 받고있는 사원과 최소급여를 받고있는 사원의 이름 급여를 조회하세요
SELECT EMP_NAME,SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE)
        OR SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);
        
-- 다중행서브쿼리 : 한개컬럼에 행이 다수가 나오는 SELECT문
-- 행이 다수이기 때문에 = 비교가 불가능, 동등비교할때는 IN / NOT IN
-- ANY, ALL, EXIST(상관서브쿼리)
-- 송종기, 박나라와 같은 부서에서 근무하는 사원의 이름 부서를 조회
SELECT EMP_NAME, DEPT_CODE 
FROM EMPLOYEE 
--WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기','박나라'));
--WHERE DEPT_CODE IN (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기','박나라'));
-- IN ('D9','D5')
WHERE DEPT_CODE NOT IN (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기','박나라'));
-- NOT IN('D9','D5');

-- 직급이 대표, 부사장이 아닌 모든 사원출력하기
-- ASIA1에서 근무하는 지원 조회하기 서브쿼리 이용할것.
SELECT * 
FROM EMPLOYEE 
WHERE DEPT_CODE IN (SELECT DEPT_ID FROM DEPARTMENT 
                        JOIN LOCATION ON LOCATION_ID=LOCAL_CODE WHERE LOCAL_NAME='ASIA1');
-- ANY||SOME
-- ANY 대소비교, 동등비교 -> ANY에 있는 값의 비교를 OR 연결
-- X >(=) ANY(값1,값2)  :  ANY에 있는 어떤 값보다 X가 크기만하면 참, 최소값보다 크면 참
-- X < ANY(값,값2) : ANY에 있는 어떤값보다 X가 작기만하면 참, 최대값보다 작은 참

SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY > ANY(SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE IN ('D5','D6'));

-- 직책이 J3인 사원들 중 최소급여보다 많이 받는 사원을 조회하기
SELECT * 
FROM EMPLOYEE
--WHERE SALARY > ANY(SELECT SALARY FROM EMPLOYEE WHERE JOB_CODE='J3');
WHERE SALARY < ANY(SELECT SALARY FROM EMPLOYEE WHERE JOB_CODE='J3');


-- ALL : 모든 값보다 크다, 작다 -> AND
--X > ALL(값, 값1) : ALL의 모든값 보다 큰 X가 참, ALL의 최대값보다 크면 참.

SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY > ALL(2000000, 5000000);

-- 부서가 D2인 사원들 중 최대급여를 받는 사원보다 급여를 받는 사원조회
SELECT EMP_NAME, SALARY
FROM EMPLOYEE 
--WHERE SALARY > ALL(SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE='D2');
WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEE WHERE DEPT_CODE='D2');


--1. 2000년1월1일 이전 입사자중에 2000년 1월1일 이후 입사자보다 급여를 (가장 높게 받는 사원보다) 
--적게 받는 사원의 사원명과 월급여를 출력하세요.
SELECT EMP_NAME, SALARY, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE < '00/01/01' 
        AND SALARY > ALL(SELECT SALARY FROM EMPLOYEE WHERE HIRE_DATE > '00/01/01');

--2. 어떤 'J4'직급의 사원보다 많은 급여를 받는 직급이 J5, J6, J7인 사원 출력.
SELECT EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE JOB_CODE IN ('J5','J6','J7')
    AND SALARY > ALL(SELECT SALARY FROM EMPLOYEE WHERE JOB_CODE='J4');

-- 다중열 서브쿼리 : 행이 한개이면서 컬럼이 여러개인 서브쿼리 
--퇴직한 여사원의 같은부서, 같은 직급에 해당하는 사원 조회
SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y';
SELECT *
FROM EMPLOYEE
--WHERE DEPT_CODE =(SELECT DEPT_CODE FROM EMPLOYEE WHERE ENT_YN='Y')
--    AND JOB_CODE=(SELECT JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y');
WHERE (DEPT_CODE, JOB_CODE) IN (SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y');


----기술지원부이면서 급여가 2000000인 사원이 있다고 한다.
--해당사원의 이름, 부서코드, 급여를 출력하기
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE (DEPT_CODE,SALARY) IN (SELECT DEPT_CODE, SALARY
                                FROM EMPLOYEE
                                    JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
                                WHERE DEPT_TITLE='기술지원부' AND SALARY=2000000);
                                
-- 다중행, 다중열 서브쿼리 : 행도 여러개, 열도 여러개 
--부서별 최소급여 구하기
SELECT DEPT_CODE, MIN(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT EMP_NAME,DEPT_TITLE, SALARY
FROM EMPLOYEE E
    JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
WHERE (DEPT_CODE,SALARY) IN (SELECT DEPT_CODE,SALARY);

-- 상관서브쿼리(상호연관)
-- 서브쿼리를 구성할때 메인쿼리에 있는 값을 가져와 사용을 하게 작성을 함.
-- 상관서브쿼리는 이중 FOR문이랑 비슷함.
-- 서브쿼리 결과에 메인쿼리의 값이 영향을 주고,서브쿼리의 결과가 메인쿼리의 결과에 영향을 주는 쿼리문

-- EXISTS : ROW 1개 이상 있다면 무조건 TRUE, ROW가 0개면 FALSE;
SELECT *
FROM EMPLOYEE
WHERE EXISTS(SELECT 1 FROM EMPLOYEE WHERE DEPT_CODE='D20');

--부하직원이 있는 사원을 조회하세요
SELECT EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE E
WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE MANAGER_ID=E.EMP_ID);

--심봉선사원과 같으 부서의 사원의 부서코드, 사원명를 조회
SELECT DEPT_CODE,EMP_NAME
FROM EMPLOYEE E
WHERE EXISTS (SELECT EMP_NAME FROM EMPLOYEE WHERE E.DEPT_CODE=DEPT_CODE AND EMP_NAME='심봉선');
                                
-- 가장 많은 급여를 받는 사원을 EXISTS연산자를 이용해서 구해보자.
-- NOT EXISTS 급여를 비교했을때 월급이 높은사람이 없을때 그사람이 최고값임
SELECT * 
FROM EMPLOYEE E
WHERE NOT EXISTS(SELECT SALARY FROM EMPLOYEE WHERE SALARY > E.SALARY);

-- 최소급여 받는 사원을 상관서브쿼리로 구하면?
SELECT * 
FROM EMPLOYEE E
WHERE NOT EXISTS(SELECT SALARY FROM EMPLOYEE WHERE SALARY < E.SALARY);

-- 스칼라서브쿼리 : 상관서브쿼리의 결과가 단일행인 쿼리문
-- 모든사원의 사번, 이름, 관리자번호, 관리자명을 조회하세요
SELECT E.EMP_ID, E.EMP_NAME, E.MANAGER_ID, M.EMP_NAME
FROM EMPLOYEE E JOIN EMPLOYEE M ON E.MANAGER_ID=M.EMP_ID;
-- 스칼라서브쿼리 이용해보자
SELECT EMP_ID, EMP_NAME, MANAGER_ID,(SELECT EMP_NAME FROM EMPLOYEE WHERE E.MANAGER_ID=EMP_ID)AS 관리자명
FROM EMPLOYEE E;

-- 사원명, 부서코드, 급여, 부서별 평균임금을 조회하자
-- 스칼라서브쿼리이용
SELECT DEPT_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE;

SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE='D9';
SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE='D6';

SELECT EMP_NAME, DEPT_CODE, SALARY,
    TO_CHAR(FLOOR((SELECT AVG(SALARY) FROM EMPLOYEE 
                    WHERE NVL(DEPT_CODE,1)=NVL(E.DEPT_CODE,1))),'L999,999,999') AS 부서별평균
FROM EMPLOYEE E;
-- 직급이 J1이 아닌 사원중에서 자신의 부서별 평균급여보다 적은 급여를 받는 사원출력
-- 부서코드, 사원명, 급여, 부서별 급여평균
SELECT DEPT_CODE, EMP_NAME, SALARY,
        FLOOR((SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE=E.DEPT_CODE)) AS 부서별평균
FROM EMPLOYEE E
WHERE JOB_CODE<>'J1' AND SALARY < (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE=E.DEPT_CODE)
ORDER BY 1;

-- 자신이 속한 직급의 평균 급여보다 많이 받는 직원의 이름, 직책명, 급여를 조회
SELECT EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE JOIN JOB USING(JOB_CODE)
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE E WHERE JOB_CODE=E.JOB_CODE);

-- 인라인 뷰 : FROM절에 SELECT문이 들어가는 것
-- 물리적인 테이블이 아닌 RESULTSET을 테이블 보는것 VIEW(가상)
-- IN-LINE VIEW : FROM 절에 서브쿼리를 사용한 것(다중열, 다중행 서브쿼리)
-- STORED VIEW : 영구적으로 저장하고 사용하는 VIEW -> VIEW수업할때 

-- 여사원의 사번, 사원명, 부서코드, 성별을 출력
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별
FROM EMPLOYEE
WHERE DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여')='여';

SELECT * 
FROM (SELECT EMP_ID, EMP_NAME, DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별
    FROM EMPLOYEE)
WHERE 성별 = '여';

-- 회원 -> memberTbl, 일반, 사업자, 관리자 / 구직자, 구인자, 일반
-- ADMIN / 1234
SELECT * 
FROM(
        SELECT MEMBER_NO,USERID, PASSWORD, '일반' AS DIV
        FROM MEMBERTBL
        UNION
        SELECT BUSINESS_NO, ID, PW, '사업자' AS DIV 
        FROM BUSINESSMEMBER 
        UNION
        SELECT MANAGER_NO, USERID, PW, '관리자' AS DIV 
        FROM MANAGER
      )
WHERE USERID='ADMIN' AND PASSWORD=1234;

--스칼라서브쿼리 메인쿼리, 서브쿼리를 이중 FOR문
SELECT DEPT_CODE, AVG(SALARY) 
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT E.* ,(SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE =E.DEPT_ID)
FROM DEPARTMENT E;

-- 사원명, 부서명, 직책명, 급여, 보너스, 성별
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY, BONUS,DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여')
FROM EMPLOYEE
    JOIN DEPARTMENT ON DEPT_ID=DEPT_CODE
    JOIN JOB USING(JOB_CODE)
WHERE DEPT_CODE='D6';

SELECT * 
FROM (
        SELECT EMP_NAME AS 사원명, DEPT_TITLE AS 부서명, JOB_NAME AS 직책명, 
        SALARY AS 월급, BONUS AS 보너스, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별
        FROM EMPLOYEE
            JOIN DEPARTMENT ON DEPT_ID=DEPT_CODE
            JOIN JOB USING(JOB_CODE)
        WHERE DEPT_CODE IN ('D5','D6')
    )
WHERE 부서명 LIKE '%해외%';


-- TOP-N분석 : ROW에 순서를 부여하는 것이라고 보면 됨. -> PAGING처리
-- 급여를 가장 많이 받는 3명, 댓글이 가장 많은 10개, 좋아요 많은 5개 게시글
SELECT * FROM EMPLOYEE ORDER BY SALARY;
-- 2가지 방법
-- 1. ROWNUM : 기본 오라클이 제공하는 컬럼 -> 모든테이블에 자동으로 설정! ROW의 순서 값
-- 2. 함수이용 : 오라클이 제공하는 TOP 

SELECT ROWNUM, E.* 
FROM EMPLOYEE E
WHERE ROWNUM BETWEEN 1 AND 10;

-- ROWNUM을 이용할때 문제발생!! 띠오띠오~
-- 급여를 가장 많이 받는 3명 사원을 조회 이름, 급여
SELECT ROWNUM, EMP_NAME, SALARY 
FROM EMPLOYEE;
--WHERE ROWNUM BETWEEN 1 AND 3
--ORDER BY SALARY DESC;

-- ROWNUM을 이용해서 순서를 적용할때는 INLINEVIEW를 이용함 
SELECT ROWNUM, E.*
FROM  (SELECT ROWNUM AS 내부ROWNUM, EMP_NAME, SALARY
        FROM EMPLOYEE 
        ORDER BY SALARY DESC) E
WHERE ROWNUM <= 10;

--D5부서의 연봉 많이 받는 사람 3명 조회하기
-- 이름, 부서코드, 급여, 연봉
--부서명으로....
SELECT EMP_NAME, DEPT_TITLE, SALARY, 연봉
FROM (
    SELECT EMP_NAME, DEPT_CODE AS 부서명, DEPT_TITLE, SALARY, SALARY*12 AS 연봉
    FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE =DEPT_ID
    ORDER BY 4 DESC
    )
WHERE ROWNUM <=3 AND 부서명='D2';    
        --SELECT * FROM EMPLOYEE;

-- 사원급여를 4번째에서 8번째 높에 받는 사원을 조회 사원명, 급여
SELECT *
FROM (
        SELECT ROWNUM AS RNUM, E.*
        FROM (
                SELECT EMP_NAME, SALARY
                FROM EMPLOYEE
                ORDER BY SALARY DESC
            ) E
    ) A           
WHERE RNUM BETWEEN 4 AND 8;    


--함수를 이용해서 순위를 매기는 방법
-- RANK() OVER(정렬기준)
SELECT EMP_NAME, SALARY,
        RANK() OVER(ORDER BY SALARY DESC) AS 순위
FROM EMPLOYEE; 

-- TOP 3를 조회하세요!
SELECT * 
FROM (
       SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC) AS 순위,
              RANK() OVER(PARTITION BY JOB_CODE ORDER BY SALARY DESC) AS "부서별 순위"
       FROM EMPLOYEE
     )
WHERE  순위 BETWEEN 1 AND 3;

--DENSE_RANK() OVER : 중복된 순위가 있을때 번호 부여에서 차이가남
SELECT RANK() OVER(ORDER BY SALARY) AS 순위,
       EMP_NAME, SALARY,
       DENSE_RANK() OVER(ORDER BY SALARY) AS DENSE순위
FROM EMPLOYEE
WHERE RANK() OVER(ORDER BY SALARY) BETWEEN 1 AND 3;       

-- 계층형 쿼리 다음시간. -> 댓글로 조회해서 가져올때 사용
-- 수직적관계를 표현할때 사용 -> 조직도, 메뉴, 답변형 게시판(댓글)

SELECT LEVEL, EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE
    START WITH EMP_ID = 200 -- 계층의 시작기준 ROOT LEVEL컬럼을 부여하는 기준
    CONNECT BY PRIOR EMP_ID=MANAGER_ID;-- 관계연결 기준
    --ORDER BY LEVEL;
--LEVEL : 계층의 정보

SELECT LEVEL||' '||LPAD(' ',(LEVEL-1)*5,' ')||EMP_NAME||NVL2(MANAGER_ID,'('||MANAGER_ID||')','') AS 조직도
FROM EMPLOYEE
    START WITH MANAGER_ID IS NULL
    --START WITH EMP_ID=200
    CONNECT BY PRIOR EMP_ID=MANAGER_ID;

-- 오라클에서 사용하는 데이터형 알아보기
-- 문자형 : CHAR, VARCHAR2 NCHAR, NVARCHAR2
-- CHAR(길이) : 고정형 문자열 타입으로 길이만큼 공간을 확보하여 사용한다. 최대 2000바이트
-- VARCHAR2(길이) : 가변형 문자열 타입으로 길이만큼 공간을 확보할 수 있다. 대입된 데이터만큼만 사용 4000바이트
-- CHAR(10), VARCHAR(10)
-- '유병승','유병승' -> CHAR형 무조건 10반영 VARCHAR2형 들어온 데이터만큼 9 반영

CREATE TABLE TBL_DATA_STR(
    A CHAR(6),
    B VARCHAR2(6),--문자열 사용에 대한 권장 자료형
    C NCHAR(6),
    D NVARCHAR2(6)
);
SELECT * FROM TBL_DATA_STR;
INSERT INTO TBL_DATA_STR VALUES('ABC','ACB','ABC','ABC');
INSERT INTO TBL_DATA_STR VALUES('가나','가','가나다','가나');
INSERT INTO TBL_DATA_STR VALUES('가','가','가','가나');
SELECT LENGTH(A),LENGTH(B),LENGTH(C),LENGTH(D)
FROM TBL_DATA_STR;

SELECT LENGTHB(A), LENGTHB(B), LENGTHB(C), LENGTHB(D)
FROM TBL_DATA_STR;

CREATE TABLE PERSON(
    NAME VARCHAR2(15)
);
--LONG : 2GB * 사용하지마 오라클
--CLOB : 4GB * 문자열 길이가 크면(4000바이트 이상) 이것을 사용 

-- 숫자형 : NUMBER
-- 실수, 정수 둘다 NUMBER 저장!
--NUMBER(PRECISION, SCALE)
-- PRECISION : 표현할수 있는 전체 자료수(1 ~ 38)
-- SCALE : 소수점이하 자리수(-84 ~ 127)
-- 둘다 생략가능
CREATE TABLE TBL_DATA_NUM(
    A NUMBER,
    B NUMBER(5),
    C NUMBER(5,1),
    D NUMBER(5,-2)
);
SELECT * FROM TBL_DATA_NUM;
INSERT INTO TBL_DATA_NUM VALUES(1234.567,1234.567,1234.567,1234.567);
INSERT INTO TBL_DATA_NUM VALUES(1234.567,12340.47,1234.54,1234.567);

-- 날짜형 : DATE
CREATE TABLE TBL_DATA_DATE(
    BIRTHDAY DATE
);

SELECT * FROM TBL_DATA_DATE;
INSERT INTO TBL_DATA_DATE VALUES('93/07/10');
INSERT INTO TBL_DATA_DATE VALUES(TO_DATE(199307100945,'YYYYMMDDHHMI'));
-- 데이터형 : BLOB, CLOB


-- 기본 테이블 생성하기
-- 테이블을 생성을 할때는 CREATE명령어를 이용
-- CREATE TABLE 테이블명( 컬럼선언,,,(컬럼명 자료형));
CREATE TABLE MEMBER (
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(20),
    MEMBER_NAME VARCHAR2(20)
);
SELECT * FROM MEMBER;

COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';

--COMMENT확인하기
SELECT * 
FROM USER_COL_COMMENTS
WHERE TABLE_NAME='MEMBER';
COMMENT ON TABLE MEMBER IS '회원정보관리';
SELECT *
FROM USER_TAB_COMMENTS;

--테이블 지우기
--DROP TABLE 테이블명;
DROP TABLE TBL_DATA_DATE;


-- 테이블에 제약조건 설정하기
-- NOT NULL(C) : 특정컬럼에 NULL을 허용하지 않는것. -> DEFAUL설정이 되어 있음 NULL값 무조건
-- UNIQUE(U) : 특정컬럼에 중복값을 허용하지 않는것 -> NULL??
-- PRIMARY KEY(P) : 데이터를 구분하는 컬럼에 지정하는 제약조건으로 UNIQUE, NOTNULL이 자동설정, 보통 테이블에 1개를 지정함.
--                  테이블에 두개 이상의 PK가 존재할 수 없음.-> 테이블당 PK는 1개!
-- FOREIGN KEY(R) : 특정컬럼의 값은 다른테이블 컬럼에 있는 값만 저장하게 하는 제약조건. 지정된 다른테이블의 컬럼은 유일해야함.
-- CHECK(C) : 특정컬럼의 값을 지정된 값만 저장할 수 있게 하는것 특정문구, 범위를 설정

-- DD를 이용해서 제약조건에 대한 정보를 확인하기
--SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
SELECT * 
FROM USER_CONSTRAINTS
WHERE TABLE_NAME='EMPLOYEE';
SELECT * 
FROM USER_CONS_COLUMNS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME
FROM USER_CONSTRAINTS JOIN USER_CONS_COLUMNS USING(CONSTRAINT_NAME);

-- NOT NULL제약조건 설정하기
CREATE TABLE TBL_CONS_N(
    USER_NO NUMBER ,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(30),
    PHONE VARCHAR2(30),
    EMILA VARCHAR2(50),
    --CONSTRAINT 이름 UNIQUE(컬럼명)
    --UNIQUE(컬럼명)
);

DROP TABLE TBL_CONS_N;

SELECT * FROM TBL_CONS_N;
--각 컬럼은 기본적으로 NULL값 허용함 
INSERT INTO TBL_CONS_N VALUES(NULL,NULL,NULL,NULL,NULL,NULL,NULL);
SELECT * FROM TBL_CONS_N;
INSERT INTO TBL_CONS_N VALUES(1,'USER01','USER01','김상현','여','010-1234-4445','SANG@SANG.COM');
-- NOT NULL제약조건 설정하기 
-- 제약조건을 설정하는 방법 1. 컬럼레벨, 2. 테이블레벨
-- 컬럼레벨에서 설정 : 컬럼선언부 옆에 설정내용을 작성
-- 테이블레벨에서 설정 : 컬럼선언이 다 끝나고 맨끝에 작성하는 것 CONSTRAINT 예약어로 작성
-- NOT NULL 제약조건 컬럼레벨에서만 선언이 가능
-- 컬럼명 타입(길이) NOT NULL,
CREATE TABLE TBL_CONS_NN(
    USER_NO NUMBER CONSTRAINT USER_NO_NN NOT NULL,--NOT NULL제약조건설정
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20),
    GENDER VARCHAR2(20),
    PHONE VARCHAR2(20),
    EMAIL VARCHAR2(50)
);
DROP TABLE TBL_CONS_NN;

SELECT * FROM TBL_CONS_NN;
INSERT INTO TBL_CONS_NN VALUES(1,'USER2','USER2','김태희','남','010-1234-5555','TEA@TEA.COM');
INSERT INTO TBL_CONS_NN VALUES(NULL,'USER2','USER2','김태희','남','010-1234-5555','TEA@TEA.COM');
INSERT INTO TBL_CONS_NN VALUES(2,NULL,'USER2','김태희','남','010-1234-5555','TEA@TEA.COM');
INSERT INTO TBL_CONS_NN VALUES(3,'USER2','USER2','김태희',NULL,'010-1234-5555','TEA@TEA.COM');

-- UNIQUE
-- 컬럼레벨, 테이블레벨도 가능
SELECT * FROM TBL_CONS_N;
INSERT INTO TBL_CONS_N VALUES(2,'USER2','USER2','김태희','남','010-1234-1234','TEA@TEA.COM');
CREATE TABLE TBL_CONS_UQ(
    USER_NO NUMBER NOT NULL,
    USER_ID VARCHAR2(20) UNIQUE,--UNIQUE제약조건이 설정됨.
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(30),
    PHONE VARCHAR2(30),
    EMILA VARCHAR2(50)
);
SELECT * FROM TBL_CONS_UQ;

INSERT INTO TBL_CONS_UQ VALUES(1,'USER2','USER2','김태희','남','010-1234-5555','TEA@TEA.COM');
INSERT INTO TBL_CONS_UQ VALUES(NULL,'USER2','USER2','김태희','남','010-1234-5555','TEA@TEA.COM');
INSERT INTO TBL_CONS_UQ VALUES(2,NULL,'USER2','김태희','남','010-1234-5555','TEA@TEA.COM');
INSERT INTO TBL_CONS_UQ VALUES(3,'USER3','USER2','김태희',NULL,'010-1234-5555','TEA@TEA.COM');

-- 그렇다면 UNIQUE제약조건이 설정된 컬럼에 NULL처리 어떻게 될까?
INSERT INTO TBL_CONS_UQ VALUES(4,NULL,'USER2','김태희',NULL,'010-1234-5555','TEA@TEA.COM');
INSERT INTO TBL_CONS_UQ VALUES(5,NULL,'USER2','김태희',NULL,'010-1234-5555','TEA@TEA.COM');
SELECT * FROM TBL_CONS_UQ;
-- 벤터회사마다 다름 

-- 테이블레벨에서 UNIQUE제약조건 설정하기
CREATE TABLE TBL_CONS_NQ2(
    USER_ID VARCHAR2(20),
    USER_PW VARCHAR2(20),
    CONSTRAINT USER_ID_UQ UNIQUE(USER_ID)
);
DROP TABLE TBL_CONS_NQ2;
SELECT * FROM TBL_CONS_NQ2;
INSERT INTO TBL_CONS_NQ2 VALUES('ADMIN','1234');
INSERT INTO TBL_CONS_NQ2 VALUES('ADMIN','5678');

-- 한개이상의 컬럼에 UNIQUE설정하기
CREATE TABLE TBL_CONS_UQ3(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    CONSTRAINT COM_NO_ID_UQ UNIQUE(USER_NO,USER_ID)
    UNIQUE(USER_NO),
    UNIQUE(USER_ID)
);
SELECT * FROM TBL_CONS_UQ3;
INSERT INTO TBL_CONS_UQ3 VALUES(1,'B','B');
INSERT INTO TBL_CONS_UQ3 VALUES(1,'A','A');
INSERT INTO TBL_CONS_UQ3 VALUES(2,'B','B');
INSERT INTO TBL_CONS_UQ3 VALUES(1,'B','C');

-- PRIMARY KEY 기본키
-- 중복값이 없고, NULL값도 없는 컬럼에 설계자가 지정함.
-- PRIMARY KEY가 설정이 되면 UNIQUE, NOT NULL제약조건 설정
-- 한개 테이블 당 한개만 설정이 가능
-- 테이블레벨, 컬럼레벨에서 설정이 가능

CREATE TABLE TBL_CONS_PK(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20)
);

SELECT * FROM TBL_CONS_PK;
INSERT INTO TBL_CONS_PK VALUES(1,'USER01','USER01','김예진');
INSERT INTO TBL_CONS_PK VALUES(2,'USER02','USER02','이진주');
INSERT INTO TBL_CONS_PK VALUES(3,'USER03','USER03','장혜린');
INSERT INTO TBL_CONS_PK VALUES(4,'USER04','USER04','장혜린');
SELECT * FROM TBL_CONS_PK 
WHERE USER_NO=3;
--WHERE USER_NAME='장혜린';

CREATE TABLE TBL_CONS_PK2(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20),
    CONSTRAINT USER_NO_PK PRIMARY KEY(USER_NO)
);

-- PK설정시 한개이상의 컬럼도 가능. --> 복합키
-- 장바구니 
CREATE TABLE TBL_ORDER(
    PRODUCT_NO NUMBER,
    USER_NO NUMBER,
    ORDER_DATE DATE,
    ORDER_NO NUMBER NOT NULL,
    PRIMARY KEY(PRODUCT_NO,USER_NO,ORDER_DATE) 
);
INSERT INTO TBL_ORDER VALUES(11,11,'21/02/26',1);
INSERT INTO TBL_ORDER VALUES(11,11,'21/02/26',1);
INSERT INTO TBL_ORDER VALUES(11,22,'21/02/26',1);
INSERT INTO TBL_ORDER VALUES(11,NULL,'21/02/26',1);
SELECT * FROM TBL_ORDER;

-- FOREIGN KEY (외래키)
-- 다른테이블의 컬럼을 가져와 쓰는것
-- 부모, 자식 관계로 설정 -> 

CREATE TABLE SHOP_MEMBER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) NOT NULL UNIQUE,
    --USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);
DROP TABLE SHOP_MEMBER;

INSERT INTO SHOP_MEMBER VALUES(1,'USER01','1234','홍길동','남','010123123','HONG@HONG.COM');
INSERT INTO SHOP_MEMBER VALUES(2,'USER02','2222','이진주','여','01012341234','JIN@JIN.COM');
INSERT INTO SHOP_MEMBER VALUES(3,'USER03','3333','장혜린','여','01033333333','JANG@JANG.COM');
INSERT INTO SHOP_MEMBER VALUES(4,'USER04','4444','김상현','남','01044444444','SANG@SANG.COM');
INSERT INTO SHOP_MEMBER VALUES(5,'USER05','5555','김예진','여','01055555555','KIM@KIM.COM');

SELECT * FROM SHOP_MEMBER;

CREATE TABLE SHOP_BUY(
    BUY_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) NOT NULL, --REFERENCES SHOP_MEMBER(USER_ID),--SHOP_MEMBER TABLE의 데이터를 가져와서 써야함.
    PRODUCT_NAME VARCHAR2(50),
    REG_DATE DATE,
    CONSTRAINT USER_ID_FK FOREIGN KEY(USER_ID) REFERENCES SHOP_MEMBER(USER_ID)
);
DROP TABLE SHOP_BUY;
SELECT * FROM SHOP_BUY;
INSERT INTO SHOP_BUY VALUES(1,'USER04','술',SYSDATE);
INSERT INTO SHOP_BUY VALUES(2,'SANG','육포',SYSDATE);
INSERT INTO SHOP_BUY VALUES(3, 'USER04','육포',SYSDATE);
INSERT INTO SHOP_BUY VALUES(4, 'USER02','커피',SYSDATE);

-- 외래키로 설정되어있는 컬럼은 함부로 지우지 못하게 설정되어있음.
-- 자식테이블에서 부모테이블 컬럼의 값을 가지고 있으면 부모테이블에서 그 값은 삭제가 불가능!

DELETE FROM SHOP_MEMBER WHERE USER_ID='USER01';


-- 외래키설정시 컬럼에 대한 삭제 옵션을 설정할 수 있다.
-- ON DELETE SET NULL / ON DELETE CASCADE 
CREATE TABLE SHOP_BUY(
    BUY_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20), --REFERENCES SHOP_MEMBER(USER_ID),--SHOP_MEMBER TABLE의 데이터를 가져와서 써야함.
    PRODUCT_NAME VARCHAR2(50),
    REG_DATE DATE,
    --CONSTRAINT USER_ID_FK FOREIGN KEY(USER_ID) REFERENCES SHOP_MEMBER(USER_ID) ON DELETE SET NULL
    CONSTRAINT USER_ID_FK FOREIGN KEY(USER_ID) REFERENCES SHOP_MEMBER(USER_ID) ON DELETE CASCADE
);
DROP TABLE SHOP_BUY;

INSERT INTO SHOP_BUY VALUES(1, 'USER03','테슬라',SYSDATE);

SELECT * FROM SHOP_BUY;
DELETE FROM SHOP_MEMBER WHERE USER_ID='USER03';


-- CHECK 제약조건

CREATE TABLE USER_CHECK(
    USER_NO NUMBER,
    USER_NAME VARCHAR2(20),
    GENDER VARCHAR2(10) CHECK(GENDER IN('남','여')),
    AGE NUMBER,
    CHECK(AGE > 19 AND USER_NO > 0) 
);
DROP TABLE USER_CHECK;
INSERT INTO USER_CHECK VALUES(2,'양호준','남',18);
INSERT INTO USER_CHECK VALUES(1,'양호준','남');
INSERT INTO USER_CHECK VALUES(2,'김상현','여');
SELECT * FROM USER_CHECK;
--TEST_MEMBER 테이블
--MEMBER_CODE(NUMBER) - 기본키						-- 회원전용코드 
--MEMBER_ID (varchar2(20) ) - 중복금지					-- 회원 아이디
--MEMBER_PWD (char(20)) - NULL 값 허용금지					-- 회원 비밀번호
--MEMBER_NAME(nchar(10)) 							-- 회원 이름
--MEMBER_ADDR (char(50)) - NULL값 허용금지					-- 회원 거주지
--GENDER (varchar2(5)) - '남' 혹은 '여'로만 입력 가능				-- 성별
--PHONE(varchar2(20)) - NULL 값 허용금지 					-- 회원 연락처

-- 서브쿼리를 이용한 테이블생성하기
-- CREATE TABLE 테이블명( 컬럼내용설정)
-- CREATE TABLE 테이블명 AS 서브쿼리
CREATE TABLE EMP_COPY 
AS SELECT * FROM EMPLOYEE;
SELECT * FROM EMP_COPY;

CREATE TABLE EMP_DEP_COPY
AS 
SELECT * 
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID;
SELECT * FROM EMP_DEP_COPY;

CREATE TABLE DEPT_COPY
AS 
SELECT * 
FROM DEPARTMENT
WHERE 100=1;
SELECT * FROM DEPT_COPY;

--INSERT문 활용하기
--INSERT문은 테이블에 한개 ROW를 삽입하는 것. 
-- 한번에 한개의 데이터만 삽입
-- 1. 컬럼을 지정해서 데이터는 삽입하는 방법
-- INSERT INTO 테이블명(컬럼명,컬럼명,컬럼명.....) VALUES(값1, 값2,....
-- 지정되지 않은 컬럼의 값은 NULL값이 대입됨. * NOT NULL제약조건 주의!
-- 2. 전체 컬럼에 데이터를 삽입하는 방법
-- INSERT INTO 테이블명 VALUES(값1, 값2......)
SELECT * FROM DEPARTMENT;
INSERT INTO DEPARTMENT(DEPT_ID, DEPT_TITLE, LOCATION_ID)
VALUES('D0','자바연구부','L2');
DESC DEPARTMENT;
SELECT * FROM DEPARTMENT;
INSERT INTO DEPARTMENT VALUES('D','오라클연구부','L3');
DELETE FROM DEPARTMENT WHERE DEPT_ID='D0';

INSERT INTO DEPARTMENT(DEPT_ID, LOCATION_ID) VALUES('D0','L5');

-- EMPLOYEE테이블에 본인정보를 삽입하기.

-- 추가적인 INSERT문 활용하기
-- 1. 서브쿼리를 이용하여 INSERT하기
CREATE TABLE INSERT_TEST
AS SELECT EMP_ID, EMP_NAME, DEPT_TITLE 
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
WHERE 1=0;

SELECT * FROM INSERT_TEST;
INSERT INTO INSERT_TEST VALUES('999','유병승','자바연구부');
--서브쿼리이용 데이터 넣기.
INSERT INTO INSERT_TEST(SELECT EMP_ID, EMP_NAME, DEPT_TITLE 
                        FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
                        WHERE DEPT_CODE='D5');                 
DELETE FROM INSERT_TEST;

--원하는 컬럼을 지정해서 넣을 수 있음
INSERT INTO INSERT_TEST(EMP_ID,EMP_NAME)(SELECT EMP_ID, EMP_NAME FROM EMPLOYEE WHERE DEPT_CODE='D6');
SELECT * FROM INSERT_TEST;

-- INSERT ALL
-- 두개 이상의 테이블에 값을 넣을때 사용
-- 한개 쿼리문에서 두개 테이블에 각각 값을 넣을때 사용
CREATE TABLE EMP_HIRE_DATE
AS 
SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE WHERE 1=0;
CREATE TABLE EMP_MANAGER
AS
SELECT EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE WHERE 1=0;

SELECT * FROM EMP_HIRE_DATE;
SELECT * FROM EMP_MANAGER;

INSERT ALL
INTO EMP_HIRE_DATE VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
INTO EMP_MANAGER VALUES(EMP_ID, EMP_NAME, MANAGER_ID)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, MANAGER_ID
FROM EMPLOYEE;


--조건에 따라 데이터를 각 테이블에 분리하여 저장하기
CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
    FROM EMPLOYEE
    WHERE 1=0;
CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
    FROM EMPLOYEE
    WHERE 1=0;
SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;
--00/01/01기준으로 이전입사자는 EMP_OLD, 이후 입사자는 EMP_NEW에 대입하기
INSERT ALL
WHEN '00/01/01'>HIRE_DATE THEN INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, SALARY, HIRE_DATE)
WHEN '00/01/01'<=HIRE_DATE THEN INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, SALARY, HIRE_DATE)
SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
FROM EMPLOYEE;

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

-- UPDATE : 한개 또는 그이상의 ROW(DATA)를 수정하는 명령어
-- UPATE 테이블명 SET 컬럼명 = 값, 컬럼명 = 값, 컬럼명= 값 [WHERE 조건식] * 생략하며 안돼!!! 큰일나!
CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;
SELECT * FROM DEPT_COPY;
UPDATE DEPT_COPY SET DEPT_TITLE='자바연구부' WHERE DEPT_ID='D0';
--다수의 컬럼을 수정할때
UPDATE DEPT_COPY SET DEPT_TITLE='JDBC연구부', DEPT_ID='K1',LOCATION_ID='L4' WHERE DEPT_ID='D';
ROLLBACK;
COMMIT;
ROLLBACK;
SELECT * FROM DEPT_COPY;

--UPDATE에서 서브쿼리 이용하기

CREATE TABLE EMP_SALARY
AS 
SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE, SALARY, BONUS
FROM EMPLOYEE;
SELECT * FROM EMP_SALARY;

-- 방명수의 급여, 보너스를 심봉선의 데이터랑 동일하게 수정해라.
SELECT SALARY, BONUS FROM EMP_SALARY WHERE EMP_NAME='심봉선';
UPDATE EMP_SALARY SET SALARY=3500000, BONUS=0.15 WHERE EMP_NAME='방명수';
ROLLBACK;
SELECT * FROM EMP_SALARY;

UPDATE EMP_SALARY
SET (SALARY, BONUS) = (SELECT SALARY, BONUS FROM EMPLOYEE WHERE EMP_NAME='심봉선')
WHERE EMP_NAME='방명수';

-- 임시환사원의 직급을 과장, 부서를 해외영업3부로 변경하는 쿼리를 작성해보자
UPDATE EMP_SALARY 
--SET JOB_CODE=(SELECT JOB_CODE FROM JOB WHERE JOB_NAME='과장'),
--    DEPT_CODE=(SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE='해외영업3부')
SET (JOB_CODE,DEPT_CODE) = (SELECT JOB_CODE, DEPT_ID 
                                FROM JOB CROSS JOIN DEPARTMENT
                                WHERE JOB_NAME='과장' AND DEPT_TITLE='해외영업3부')
WHERE EMP_NAME='임시환';
SELECT * FROM JOB CROSS JOIN DEPARTMENT;
SELECT * FROM EMP_SALARY WHERE EMP_NAME='임시환';
ROLLBACK;
    
-- DELETE : 조건에 맞는 ROW(DATA) 삭제하는 명령어
-- DELETE FROM 테이블 [WHERE ]
-- WHERE 가 없으면 전체 삭제를 함. WHERE이 있으면 WHERE 조건이 TRUE인 ROW만 삭제
SELECT * FROM EMP_SALARY;

DELETE FROM EMP_SALARY;
ROLLBACK;
DELETE FROM EMP_SALARY WHERE BONUS IS NULL;

--DELETE 사용시 주의 : 외래키 제약조건, 삭제대상의 ROW가 다른 테이블에서 참조되고 있으면 삭제 불가능(옵션으로 변경가능)

-- TRUNCATE ROW를 삭제 -> DELETE보다 속도 빠름... BUT ROLLBACK할 수 없다.
DELETE FROM EMP_SALARY;
SELECT * FROM EMP_SALARY;
ROLLBACK;


TRUNCATE TABLE EMP_SALARY;

-- MERGE 두테이블을 합칠때 사용하는 명령어
CREATE TABLE TBL_MERGE01(
 ID VARCHAR2(20),
 NAME VARCHAR2(20)
 );
 
CREATE TABLE TBL_MERGE02(
 ID VARCHAR2(20),
 NAME VARCHAR2(20)
 );
 
 SELECT * FROM TBL_MERGE01;
 SELECT * FROM TBL_MERGE02;
 
 INSERT INTO TBL_MERGE01 VALUES('USER11','유병승');
 INSERT INTO TBL_MERGE01 VALUES('USER22','김상현');
 INSERT INTO TBL_MERGE02 VALUES('USER33','김태희');
 INSERT INTO TBL_MERGE02 VALUES('USER22','김예진');
 
 MERGE INTO TBL_MERGE01
 USING TBL_MERGE02 ON (TBL_MERGE01.ID=TBL_MERGE02.ID)
 WHEN MATCHED THEN 
 UPDATE SET TBL_MERGE01.NAME=TBL_MERGE02.NAME
 WHEN NOT MATCHED THEN
 INSERT VALUES(TBL_MERGE02.ID,TBL_MERGE02.NAME);
 
 -- ALTER : 테이블 등 오라클 객체를 수정하는 명령어
 -- 컬럼을 추가, 삭제, 컬럼명 변경, 자료형 변경, DEFAULT값 설정
 -- 제약조건 변경 추가/삭제, 이름변경
 
 CREATE TABLE TBL_USER_ALTER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20)
 );
 
 SELECT * FROM TBL_USER_ALTER;
 
 --컬럼 추가하기
ALTER TABLE TBL_USER_ALTER ADD(USER_NAME VARCHAR2(20));
INSERT INTO TBL_USER_ALTER VALUES(1,'ADMIN','1234','관리자','관리','ADMIN@HOT.COM');
-- 기존에 데이터가 있는 테이블에 컬럼을 추가하면 
ALTER TABLE TBL_USER_ALTER ADD(NICKNAME VARCHAR2(20));
SELECT * FROM TBL_USER_ALTER;
DELETE FROM TBL_USER_ALTER;
ALTER TABLE TBL_USER_ALTER ADD(EMAIL VARCHAR2(50) NOT NULL);
ALTER TABLE TBL_USER_ALTER ADD(AGE NUMBER DEFAULT 0 NOT NULL);
INSERT INTO TBL_USER_ALTER(USER_NO, USER_ID,USER_NAME,EMAIL) VALUES(2,'USER00','영영','U00@U.COM');
INSERT INTO TBL_USER_ALTER VALUES(3,'USER01','USER01','영일','영일영일','A@COM',20);

-- ALTER를 이용해서 제약조건 추가하기
ALTER TABLE TBL_USER_ALTER ADD UNIQUE(USER_ID);
-- 추천하지 않음 -> 제약조건명칭이 자동으로 부여되서 구별하기 힘듬
ALTER TABLE TBL_USER_ALTER ADD CONSTRAINT UQ_USER_NAME UNIQUE(USER_NAME);

-- 제약조건삭제하기
-- DROP
ALTER TABLE TBL_USER_ALTER DROP CONSTRAINT SYS_C007125;


-- 컬럼명 수정하기
ALTER TABLE TBL_USER_ALTER RENAME COLUMN USER_PWD TO PASSWORD;
SELECT * FROM TBL_USER_ALTER;
-- 제약조건 명칭도 수정하기
ALTER TABLE TBL_USER_ALTER RENAME CONSTRAINT SYS_C007122 TO PK_TBL_USER;

-- 컬럼 타입을 변경하기
-- MODIFY예약어 사용
ALTER TABLE TBL_USER_ALTER MODIFY USER_NAME VARCHAR2(5);
 DESC TBL_USER_ALTER;

--NOT NULL 제약조건 TBL_USER_ALTER USER_NAME컬럼에 설정
-- ALTER TABLE TBL_USER_ALTER ADD CONSTRAINT NN_USER_NAME NOT NULL;
-- NULL에 대한 제약조건은 DEFAULT로 설정되었음 -> MODIFY로 변경을 해줘야함.
ALTER TABLE TBL_USER_ALTER MODIFY USER_NAME CONSTRAINT NN_USER_NAME NOT NULL;

-- 컬럼 삭제
-- DROP
ALTER TABLE TBL_USER_ALTER DROP COLUMN USER_NAME;
 SELECT * FROM TBL_USER_ALTER;
    
    
-- 테이블 명칭 변경하기
ALTER TABLE TBL_USER_ALTER RENAME TO CHANGE_TABLE;
SELECT * FROM TBL_USER_ALTER;
SELECT * FROM CHANGE_TABLE;
RENAME CHANGE_TABLE TO TBL_USER_ALTER;


-- DROP TABLE : 테이블 삭제하기
DROP TABLE TBL_USER_ALTER;
-- DROP TABLE 시 참조관계(외래키설정)
CREATE TABLE TBL_USER(
    EMP_ID VARCHAR2(20) REFERENCES EMP_DEP_COPY(EMP_ID)
);

ALTER TABLE EMP_DEP_COPY ADD CONSTRAINT UQ_EMP_ID UNIQUE(EMP_ID);

DROP TABLE EMP_DEP_COPY;

DROP TABLE EMP_DEP_COPY CASCADE CONSTRAINT;

DROP TABLE TBL_USER;

-- DCL : DATA CONTROL LANGUAGE
-- 데이터 제어 언어, DB에 대한 보안, 무결성, 복구등 DBMS를 제어하기 위한 언어
-- 권한부여(GRANT, REVOKE), TCL 트렌젝션관리(COMMIT, ROLLBACK)

-- GRANT : 사용자에게 권한|ROLE 을 부여하는 명령어.
-- GRANT 권한|ROLE명칭 TO 사용자 계정 [WITH ADMIN OPTION]

CREATE USER QWER IDENTIFIED BY QWER;

GRANT CREATE SESSION TO QWER; --권한명으로 권한을 부여
GRANT CONNECT TO QWER; --ROLE 지정된 권한을 부여

--사용자에게 부여된 권한 조회
SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE='QWER';

SELECT * FROM DBA_ROLE_PRIVS
WHERE GRANTEE='KH';

SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE='KH';

SELECT * FROM USER_ROLE_PRIVS;

-- QWER계정에는 CREATE SESSION권한만 부여가 되어있음
-- 접속만 가능 
CREATE TABLE TEST(
    NAME VARCHAR2(20)
);

GRANT CREATE TABLE TO QWER;
--ALTER USER QWER QUOTA UNLIMITED ON USERS;
ALTER USER QWER DEFAULT TABLESPACE USERS;--TABLESPACE에 대한 영역확보

SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE='CONNECT';
SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE='RESOURCE';

--권한을 부여하여 다른 계정에 있는 테이블 이용하게 만들기
SELECT * FROM KH.DEPARTMENT;
GRANT SELECT ON KH.DEPARTMENT TO QWER;
GRANT INSERT ON KH.DEPARTMENT TO QWER;

INSERT INTO KH.DEPARTMENT VALUES('K3','백수부2','L3');
COMMIT;
SELECT * FROM DEPARTMENT;


--REVOKE 권한을 회수
REVOKE INSERT ON KH.DEPARTMENT FROM QWER;

GRANT INSERT, SELECT, UPDATE, DELETE ON KH.EMPLOYEE TO QWER;
REVOKE INSERT, SELECT, UPDATE, DELETE ON KH.EMPLOYEE FROM QWER;

-- 트렌젝션 : 작업의 단위
-- 트렌젝션은 INSERT, UPDATE, DELETE -> 테이블의 데이터를 조작할때 사용
SELECT * FROM TBL_USER;
INSERT INTO TBL_USER VALUES('USER01');
INSERT INTO TBL_USER VALUES('USER02');
INSERT INTO TBL_USER VALUES('USER03');
COMMIT;
UPDATE TBL_USER SET EMP_ID='TEST';
ROLLBACK;
SELECT * FROM KH.TBL_USER;
INSERT INTO KH.TBL_USER VALUES('USER04');
INSERT INTO KH.TBL_USER VALUES('USER05');
INSERT INTO KH.TBL_USER VALUES('USER06');
COMMIT;

-- VIEW : 가상의테이블(RESULTSET) SELECT문을 이용해서 실제 테이블에서 데이터를 가져와 사용
-- VIEW ORACLE OBJECT로 DDL구문을 이용하여 생성, 수정, 삭제,
-- CREATE VIEW VIEW명칭 AS SELECT문 
CREATE VIEW V_EMPLOYEEALL
AS SELECT * 
    FROM EMPLOYEE 
    JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    JOIN JOB USING(JOB_CODE);
--VIEW를 생성하게 하려면 권한을 부여해야함. CREATE VIEW
GRANT CREATE VIEW TO KH;

--VIEW를 생성하고나면 VIEW명칭을 FROM절에 사용하여 테이블 처럼 사용이 가능하다.
SELECT * FROM V_EMPLOYEEALL;
SELECT * FROM (SELECT......)
--저장된 VIEW확인 하기
SELECT * FROM USER_VIEWS;

CREATE VIEW V_EMP_UNION
AS SELECT EMP_NAME,SALARY
    FROM EMPLOYEE
    UNION
    SELECT DEPT_TITLE, 10
    FROM DEPARTMENT;
SELECT * FROM V_EMP_UNION;
            
CREATE VIEW V_EMPAVG
AS  SELECT DEPT_CODE,FLOOR(AVG(SALARY)) AS 평균
    FROM EMPLOYEE
    GROUP BY DEPT_CODE
    UNION
    SELECT JOB_CODE,FLOOR(AVG(SALARY))AS 평균
    FROM EMPLOYEE
    GROUP BY JOB_CODE
    UNION
    SELECT '총평균', FLOOR(AVG(SALARY))AS 평균
    FROM EMPLOYEE;
    
SELECT * FROM V_EMPAVG;

-- VIEW삭제하기
DROP VIEW V_EMP_UNION;
SELECT * FROM USER_VIEWS;

--뷰특징
--1. 컬럼, 산술연산까지 포함할 수 있다. 단 산술연산에는 반드시 별칭을 부여
CREATE VIEW V_EMP_SALARY
AS SELECT EMP_NAME, (SALARY+(SALARY*NVL(BONUS,0)))*12 AS 연봉
    FROM EMPLOYEE;
SELECT * FROM V_EMP_SALARY;

-- VIEW권한을 부여해서 이용가능하게 만들 수 있다.
SELECT * FROM KH.EMPLOYEE;
SELECT * FROM KH.DEPARTMENT;
--VIEW에 대한 권한 부여해보기
GRANT SELECT ON KH.V_EMPLOYEEALL TO QWER;
SELECT * FROM KH.V_EMPLOYEEALL;
SELECT * FROM KH.EMPLOYEE;
SELECT * FROM KH.JOB;

-- VIEW로 DML활용하기
-- INSERT, UPDATE, DELETE -> 가능하면 실제 테이블에 있는 값이 변경
-- 만약에 가상컬럼(실제테이블에 존재하지 않는 컬럼)이 존재한다면 DML불가능
SELECT * FROM V_EMP_SALARY;
UPDATE V_EMP_SALARY SET EMP_NAME='테스트';
DELETE FROM V_EMP_SALARY WHERE EMP_NAME='고두밋';
SELECT * FROM EMPLOYEE;
ROLLBACK;

CREATE VIEW V_EMP
AS SELECT EMP_ID, EMP_NO, EMP_NAME, EMAIL, PHONE, JOB_CODE, SAL_LEVEL
    FROM EMPLOYEE;

INSERT INTO V_EMP VALUES('500','930710-1258321','김상현','SANG@SANG.COM','190213023','J2','S3');
SELECT * FROM V_EMP;
SELECT * FROM EMPLOYEE;
UPDATE V_EMP SET DEPT_CODE='D5' WHERE EMP_NAME='김상현';


--DML구문이 조작이 불가능한 경우
--1. 뷰에서 정의하고 있지 않은 컬럼을 조작하는경우
--2. 뷰에 포함되지 않은 컬럼중 베이스(실제테이블)가 되는 컬럼에 NOT NULL제약조건이 설정되었을때
--3. 산술연산으로 구성된 컬럼(가상컬럼)
--4. 그룹함수, GROUP BY절이 포함된 VIEW
--5. DISTINCT를 포함하고 있는 경우
--6. JOIN을 통해 여러테이블을 연결하고 있는 경우 * 예외상황이 있음.


-- VIEW옵션
--1. OR REPLACE
CREATE OR REPLACE VIEW V_EMP_SALARY
AS SELECT * FROM EMPLOYEE;
SELECT * FROM USER_VIEWS;

--2. FORCE/NOFORCE옵션  : 실제테이블이 없어도 VIEW를 먼저 생성할 수 있게 해주는 옵션
CREATE FORCE VIEW V_FORCETEST
AS SELECT A,B,C FROM NOTHINGBETTER;
SELECT * FROM V_FORCETEST;
CREATE TABLE NOTHINGBETTER(
    A NUMBER,
    B NUMBER,
    C NUMBER
    );

-- 3. WITH CHECK OPTION 
-- SELECT문의 WHERE절에서 사용한 컬럼을 수정하지 못하게 하는 옵션
CREATE OR REPLACE VIEW V_CHECKOPTION
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_CODE
    FROM EMPLOYEE 
    WHERE DEPT_CODE='D5' WITH CHECK OPTION;
SELECT * FROM V_CHECKOPTION;
UPDATE V_CHECKOPTION SET SALARY=6000000 WHERE EMP_ID=215;
ROLLBACK;

--4. WITH READ ONLY
-- VIEW자체를 수정 못하게 차단하는 옵션
CREATE OR REPLACE VIEW V_READ
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_CODE
    FROM EMPLOYEE
    WHERE DEPT_CODE='D5' WITH READ ONLY;
UPDATE V_READ SET SALARY=100000000;

--SEQUENCE이용하기
--자동번호 부여기
-- CREATE SEQUENCE 시퀀스명 [옵션들]
-- 시퀀스작동예약어 -> 시퀀명.NEXTVAL, 시퀀스명.CURRVAL
-- 기본시퀀스 생성하기
CREATE SEQUENCE SEQ_BASIC;
SELECT SEQ_BASIC.NEXTVAL FROM DUAL;
SELECT SEQ_BASIC.CURRVAL FROM DUAL;
CREATE SEQUENCE SEQ_OPTION
START WITH 100
INCREMENT BY 10;
SELECT SEQ_OPTION.NEXTVAL FROM DUAL;

CREATE SEQUENCE SEQ_OPTION2
START WITH 60
INCREMENT BY 6
MAXVALUE 90
MINVALUE 0
CYCLE
NOCACHE;
SELECT SEQ_OPTION2.NEXTVAL FROM DUAL;
CREATE SEQUENCE SEQ_OPTION3
START WITH 60
INCREMENT BY 6
MAXVALUE 90
MINVALUE 0
NOCACHE;
SELECT SEQ_OPTION3.NEXTVAL FROM DUAL;


CREATE TABLE BOARD (
    BOARD_NO NUMBER PRIMARY KEY,
    BOARD_TITLE VARCHAR2(200) NOT NULL,
    BOARD_CONTENT VARCHAR2(800),
    BOARD_WRITER VARCHAR2(20) REFERENCES EMPLOYEE(EMP_ID),
    BOARD_DATE DATE
);
CREATE SEQUENCE SEQ_BOARD_NO;
INSERT INTO BOARD VALUES(SEQ_BOARD_NO.NEXTVAL,'상현씨 글','상현씨가 태희씨에게 커피를 셔틀시킴','200',SYSDATE);
INSERT INTO BOARD VALUES(SEQ_BOARD_NO.NEXTVAL,'태희씨 글','전 피해자에요... 흑흑..ㅠㅠ','201',SYSDATE);
SELECT * FROM BOARD;

--SEQUENCE정보 조회하기
SELECT * FROM USER_SEQUENCES;

SELECT 'B_'||SEQ_BOARD_NO.NEXTVAL FROM DUAL;

--시퀀스 수정하기
ALTER SEQUENCE SEQ_BOARD_NO
MAXVALUE 1000;
SELECT * FROM USER_SEQUENCES;

--시퀀스 지우기
DROP SEQUENCE SEQ_OPTION;

--NEXTVAL, CURRVAL
-- CURRVAL 동일세션에서 NEXTVAL한번이라도 실행 한 후 조회가 가능
CREATE SEQUENCE SEQ_TEST;
SELECT SEQ_TEST.NEXTVAL FROM DUAL;
SELECT SEQ_TEST.CURRVAL FROM DUAL;
-- 사용할 수 없는 구문
-- VIEW의 SELECT구문
-- DISTINCT포함된 SELECT문
-- GROUP BY HAVING ORDER BY 가 있는 SELECT문
-- SELECT, DELTE, UPDATE 서브쿼리
-- CREATE TABLE, ALTER TABLE의 DEFAULT값에


-- INDEX : 전체적인 DBMS 성능향상을 위해설정.
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_IND_COLUMNS;

SELECT * FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID WHERE EMP_NAME='송종기';

CREATE INDEX IND_EMPLOYEE ON EMPLOYEE(EMP_NAME);

SELECT * FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID WHERE EMP_NAME='김상현';

DROP INDEX IND_EMPLOYEE;
--여러컬럼에 인덱스를 부여할 수 있음
CREATE INDEX IND_EMPLOYEE_COM ON EMPLOYEE(EMP_NAME, DEPT_CODE);

SELECT * FROM EMPLOYEE 
WHERE EMP_NAME='박나라' AND DEPT_CODE='D5';


-- PL/SQL구문
-- 유형
-- 익명 블록 -> 이름이 없어서 재호출이 불가능.
-- 프로시저, 함수 -> 이름이 있어서 재호출이 가능함.

--구조
-- DECALRE  선언부
--  변수를 선언.
-- BEGIN  실행부
--  제어문, 반복문, 함수 등
-- EXCEPTION 예외처리부
--  예외발생상황을 처리
--END;

SET SERVEROUTPUT ON;

BEGIN
    DBMS_OUTPUT.PUT_LINE('나의 첫 PL/SQL');
END;
/

DECLARE
    VID VARCHAR2(20);
BEGIN
    SELECT EMP_ID
    INTO VID
    FROM EMPLOYEE WHERE EMP_NAME='김상현';
    
    DBMS_OUTPUT.PUT_LINE('VID : '||VID);
END;
/

-- 변수선언하기
-- 변수명 [CONSTANT] 자료형(바이트) [NOT NULL] ;
-- 변수명 자료형 := 초기값;

DECLARE
    V_EMPNO NUMBER;
    V_EMPNAME VARCHAR2(20);
    TEST_NUM NUMBER:=10+30;
BEGIN
    V_EMPNO:=999;
    V_EMPNAME:='차태현';
    DBMS_OUTPUT.PUT_LINE('사번 : '||V_EMPNO);
    DBMS_OUTPUT.PUT_LINE('이름 : '||V_EMPNAME);
    DBMS_OUTPUT.PUT_LINE('번호 : '||TEST_NUM);
END;
/

-- 변수 자료형타입을 알아보자
-- 자료형은 기본자료형(ORACLE자료형), 복합자료형으로 구분됨.
-- 기본자료형 : NUMBER, VARCHAR2, DATE, BOOLEAN, BINARY_INTEGER
-- 복합자료형 : 레코드, 커서, 컬렉션

-- 종료 : 일반변수, 참조형변수(테이블의 컬럼에 지정된 자료형을 가져와 사용)

--참조형변수
--1. %TYPE : 지정한 테이블의 컬럼의 자료형을 참조하는 레퍼런스자료형
DECLARE
    V_EMP_ID EMPLOYEE.EMP_ID%TYPE;
    V_SALARY EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT EMP_ID, SALARY
    INTO V_EMP_ID, V_SALARY
    FROM EMPLOYEE
    WHERE EMP_ID=200;
    DBMS_OUTPUT.PUT_LINE(V_EMP_ID||' '||V_SALARY);
END;
/
--2. %ROWTYPE : 테이블에 지정되어있는 한개 ROW의 컬럼들을 모두 가져오는 자료형
DECLARE
    VEMP EMPLOYEE%ROWTYPE;
BEGIN
    SELECT * 
    INTO VEMP
    FROM EMPLOYEE
    WHERE EMP_NAME='송종기';
    
    DBMS_OUTPUT.PUT_LINE(VEMP.EMP_ID||VEMP.EMP_NAME||VEMP.SALARY);
END;
/

-- 레코드 : 클래스 
DECLARE
    TYPE MY_RECODE IS RECORD(
        ID EMPLOYEE.EMP_ID%TYPE,
        NAME EMPLOYEE.EMP_NAME%TYPE,
        TITLE DEPARTMENT.DEPT_TITLE%TYPE
    );
    MY MY_RECODE;
BEGIN
    SELECT EMP_ID, EMP_NAME, DEPT_TITLE
    INTO MY
    FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    WHERE EMP_NAME='전지연';
    
    DBMS_OUTPUT.PUT_LINE(MY.ID||' '||MY.NAME||' ' ||MY.TITLE);
END;
/

-- 컬렉션 자료형
-- 컬렉션은 자바의 배열과 같은 형태를 가지고 있음.
DECLARE
    TYPE VA_TYPE IS VARRAY(5) OF VARCHAR2(10);
    V_VA VA_TYPE;
    V_CNT NUMBER:=0;
BEGIN
    V_VA:=VA_TYPE('FIRST','SECOND','THIRD','','');
    LOOP
        V_CNT:=V_CNT+1;
        IF V_CNT > 5 THEN  EXIT;
        END IF;
        DBMS_OUTPUT.PUT_LINE(V_CNT||' '||V_VA(V_CNT));
    END LOOP;
END;
/

-- TABLE자료형 배열
DECLARE
    TYPE EMP_ID_TABLE_TYPE IS TABLE OF EMPLOYEE.EMP_ID%TYPE
    INDEX BY BINARY_INTEGER;
    EMP_ID_TABLE EMP_ID_TABLE_TYPE;
    I BINARY_INTEGER:=0;
BEGIN
    FOR K IN (SELECT EMP_ID FROM EMPLOYEE) LOOP
        I:=I+1;
        EMP_ID_TABLE(I):=K.EMP_ID;
    END LOOP;
    FOR J IN 1..I LOOP
        DBMS_OUTPUT.PUT_LINE(EMP_ID_TABLE(J));
    END LOOP;
END;
/
-- PL/SQL구문에서 SELECT문 사용하기
-- PL/SQL구문에서 SELECT문을 사용하는 것은 조회한 결과를 변수에 저장하고 활용하기 위해서 사용
-- PL/SQL구문에서 SELECT문을 사용할때는 반드시 INTO를 사용하여 대입하는 구문을 만들어줘야한다.
DECLARE
    EMP_ID EMPLOYEE.EMP_ID%TYPE;
BEGIN 
    SELECT EMP_ID 
    INTO EMP_ID
    FROM EMPLOYEE
    WHERE EMP_NAME='방명수';
END;
/
SELECT * FROM EMPLOYEE;

-- PL/SQL구문을 이용하여 INSERT문 처리하기

BEGIN
    FOR K IN 1..10 LOOP
        INSERT INTO MEMBER VALUES('USER0'||K,'USER0'||K,'유저공'||k);
        COMMIT;
    END LOOP;
END;
/
SELECT * FROM MEMBER;


--1. 사원 번호를 입력 받아서 받은 사원의 사원번호, 이름, 부서코드, 부서명을 출력하도록 하시오
--      각 컬럼별 변수를 생성하기
DECLARE
    VEMPID EMPLOYEE.EMP_ID%TYPE;
    VEMPNAME EMPLOYEE.EMP_NAME%TYPE;
    VDEPT_CODE EMPLOYEE.DEPT_CODE%TYPE;
    VDEPT_TITLE DEPARTMENT.DEPT_TITLE%TYPE;
BEGIN
    SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
    INTO VEMPID, VEMPNAME,VDEPT_CODE, VDEPT_TITLE
    FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    WHERE EMP_ID='&EMP_ID';
    DBMS_OUTPUT.PUT_LINE(VEMPID);
    DBMS_OUTPUT.PUT_LINE(VEMPNAME);
    DBMS_OUTPUT.PUT_LINE(VDEPT_CODE);
    DBMS_OUTPUT.PUT_LINE(VDEPT_TITLE);
END;
/
--2. 사원 번호를 입력 받아서 해당 사원의 정보(한 행)를 한 변수에  모두 입력 받아 
--   사번,이름,주민번호,급여를 출력하여라.
DECLARE
    E EMPLOYEE%ROWTYPE;
BEGIN
    SELECT * 
    INTO E
    FROM EMPLOYEE
    WHERE EMP_ID='&사원명';
    DBMS_OUTPUT.PUT_LINE(E.EMP_ID||E.EMP_NAME||E.EMP_NO||E.SALARY);
END;
/
SET SERVEROUTPUT ON

--3. EMPLOYEE테이블에서 사번 마지막번호를 구한뒤, +1한 사번에 사용자로 부터 입력받은 
-- 이름, 주민번호, 전화번호, 직급코드(J5), 급여등급(S5)를 등록하는 PL/SQL을 작성하자.
DECLARE
    ID EMPLOYEE.EMP_ID%TYPE;
BEGIN
    SELECT MAX(EMP_ID)
    INTO ID
    FROM EMPLOYEE;
    
    INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME,EMP_NO,PHONE, JOB_CODE, SAL_LEVEL)
    VALUES(ID+1, '&이름','&주민번호','&전화번호','&직책코드','&급여코드');
    COMMIT;
END;
/
SELECT * FROM EMPLOYEE;



begin
    insert into member values('&아이디','&비밀번호','&이름');
    commit;
end;
/
SELECT * FROM MEMBER;

-- PL/SQL 조건문
-- 사용법 실행문에 사용
-- IF 조건식 ~ THEN 조건이 TRUE일때 실행할 로직 ~ END IF문
DECLARE
    V_EMP_NAME EMPLOYEE.EMP_NAME%TYPE;
BEGIN
    SELECT EMP_NAME
    INTO V_EMP_NAME
    FROM EMPLOYEE 
    WHERE EMP_ID='&사번';

    IF V_EMP_NAME='선동일' THEN
        DBMS_OUTPUT.PUT_LINE('난 대표!');
    END IF;
END;
/
-- IF ~ THEN ~ ELSE ~ END IF;
DECLARE 
    V_EMP_NAME EMPLOYEE.EMP_NAME%TYPE;
BEGIN
    SELECT EMP_NAME
    INTO V_EMP_NAME
    FROM EMPLOYEE
    WHERE EMP_ID='&사원아이디';
    
    IF V_EMP_NAME='선동일' THEN
        DBMS_OUTPUT.PUT_LINE('대표다');
    ELSE DBMS_OUTPUT.PUT_LINE('사원이다!');
    END IF;
END;
/
-- IF ~ THEN ~ ELSIF ~ ELSE ~ END IF    
DECLARE 
    V_JOB_CODE EMPLOYEE.JOB_CODE%TYPE;
BEGIN
    SELECT JOB_CODE
    INTO V_JOB_CODE
    FROM EMPLOYEE
    WHERE EMP_ID='&사원아이디';
    
    IF V_JOB_CODE='J1' THEN
        DBMS_OUTPUT.PUT_LINE('대표다');
    ELSIF V_JOB_CODE='J2' THEN
        DBMS_OUTPUT.PUT_LINE('임원이다');
    ELSE DBMS_OUTPUT.PUT_LINE('사원이다!');
    END IF;
END;
/

-- CASE문
DECLARE
    INPUTVALUE NUMBER;
BEGIN
    INPUTVALUE:='&수입력';
    CASE INPUTVALUE
        WHEN 1 THEN
            DBMS_OUTPUT.PUT_LINE(INPUTVALUE||'를 입력함 1은 첫번째');
        WHEN 2 THEN
            DBMS_OUTPUT.PUT_LINE(INPUTVALUE||'를 입력함 2은 두번째');
        WHEN 3 THEN
            DBMS_OUTPUT.PUT_LINE(INPUTVALUE||'를 입력함 3은 세번째');
        ELSE
            DBMS_OUTPUT.PUT_LINE(INPUTVALUE||'3이상은 몰랑');
    END CASE;
END;
/
DECLARE
    V_SALARY EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT SALARY 
    INTO V_SALARY
    FROM EMPLOYEE
    WHERE EMP_ID='&사번';
    
    CASE 
        WHEN V_SALARY > 4000000 THEN
         DBMS_OUTPUT.PUT_LINE('고액연봉자');
        WHEN V_SALARY > 2000000 THEN
         DBMS_OUTPUT.PUT_LINE('연봉자');   
        ELSE 
         DBMS_OUTPUT.PUT_LINE('슬프다....');
    END CASE;
END;
/
-- 반복문
-- 기본반복문 (LOOP)
-- LOOP ~실행할 구문 END LOOP -> 무한루프
-- 반복문을 빠져나오는 예약어 -> EXIT
DECLARE
    N NUMBER :=1;
BEGIN
    LOOP
        DBMS_OUTPUT.PUT_LINE(N);
        DBMS_OUTPUT.PUT_LINE(FLOOR(DBMS_RANDOM.VALUE(1,10)));
        N:=N+1;
--        IF N > 10 THEN
--            EXIT;
--        END IF;
        EXIT WHEN N>10;
    END LOOP;
END;
/

-- WHILE 조건식 LOOP
--  실행구문
-- END LOOP;

-- FOR LOOP
-- FOR EACH문과 비슷
-- FOR 변수 IN 범위 LOOP
--      실행구문
-- END LOOP;
BEGIN
    FOR I IN 1..10 LOOP
        DBMS_OUTPUT.PUT_LINE(I);
    END LOOP;
END;
/
SET SERVEROUTPUT ON;
BEGIN 
    FOR I IN REVERSE 1..10 LOOP
     DBMS_OUTPUT.PUT_LINE(I);
    END LOOP;
END;
/
-- FOR LOOP를 이용해서 EMPLOYEE의 10개 ROW출력하기
-- EMP_ID, EMP_NAME, SALARY
DECLARE
    V_EMP_ID EMPLOYEE.EMP_ID%TYPE;
    E EMPLOYEE%ROWTYPE;
BEGIN
    V_EMP_ID:=200;
    FOR K IN 1..10 LOOP
        SELECT *
        INTO E
        FROM EMPLOYEE
        WHERE EMP_ID=V_EMP_ID;
        V_EMP_ID:=V_EMP_ID+1;-- SUM+=I;
        --DBMS_OUTPUT.PUT_LINE(V_EMP_ID);
        DBMS_OUTPUT.PUT_LINE(E.EMP_ID||E.EMP_NAME||E.SALARY);
    END LOOP;
END;
/






-- PROCEDURE : PL/SQL구문을 저장해서 이용하게 하는 객체
CREATE TABLE PRO_TEST
AS SELECT * FROM EMPLOYEE;
SELECT * FROM PRO_TEST;

--프로시저만들기.
CREATE PROCEDURE DEL_DATA
IS
--지역변수선언
BEGIN
    DELETE FROM PRO_TEST;
    COMMIT;
END;
/
--생성되 프로시져 조회
SELECT * FROM USER_PROCEDURES;
--생성된 프로시져 실행하기
EXEC DEL_DATA;

SELECT * FROM PRO_TEST;


-- 프로시져에도 매개변수를 선언하는것이 가능함.
-- IN : 프로시져 실행시 필요한 값을 받는 변수(자바에서 선언한 매개변수와 동일)
-- OUT : 호출한곳으로 되돌려 주는 변수(결과값)
CREATE OR REPLACE PROCEDURE PRO_SELECT_EMP(V_EMP_ID IN EMPLOYEE.EMP_ID%TYPE,
                                V_EMP_NAME OUT EMPLOYEE.EMP_NAME%TYPE,
                                V_SALARY OUT EMPLOYEE.SALARY%TYPE,
                                V_BONUS OUT EMPLOYEE.BONUS%TYPE)
IS 
BEGIN
    SELECT EMP_NAME, SALARY,BONUS
    INTO V_EMP_NAME, V_SALARY,V_BONUS
    FROM EMPLOYEE
    WHERE EMP_ID=V_EMP_ID;
END;
/

-- 매개변수가 있는 프로시져실행하기
VAR EMP_NAME VARCHAR2(20);
VAR SALARY NUMBER;
VAR BONUS NUMBER;

EXEC PRO_SELECT_EMP(200,:EMP_NAME,:SALARY,:BONUS);

PRINT EMP_NAME;
PRINT SALARY;
PRINT BONUS;


-- FUNCTION만들기
-- 반환형이 있음.
CREATE OR REPLACE FUNCTION MYFUNC(V_STR VARCHAR2)
RETURN VARCHAR2
IS
    RESULT VARCHAR2(1000);
BEGIN
    DBMS_OUTPUT.PUT_LINE(V_STR);
    RESULT:='*'||V_STR||'*';
    RETURN RESULT;
END;
/

SELECT MYFUNC('김태희') FROM DUAL;

-- EMP_ID를 전달받아 연봉을 계산해서 출력해주는 함수만들기.
CREATE OR REPLACE FUNCTION CALC_SALARY(V_EMP_ID EMPLOYEE.EMP_ID%TYPE)
RETURN NUMBER
IS
    E EMPLOYEE%ROWTYPE;
    RESULT NUMBER;
BEGIN
    SELECT *
    INTO E
    FROM EMPLOYEE
    WHERE EMP_ID=V_EMP_ID;
    RESULT:=(E.SALARY+(E.SALARY*NVL(E.BONUS,0))*12);
    RETURN RESULT;
END;
/

SELECT EMP_ID, CALC_SALARY(EMP_ID)
FROM EMPLOYEE;

-- 트리거 C
CREATE OR REPLACE TRIGGER TRG_01
AFTER INSERT
ON EMPLOYEE
FOR EACH ROW
BEGIN 
    DBMS_OUTPUT.PUT_LINE(:NEW.EMP_ID);
    DBMS_OUTPUT.PUT_LINE(:NEW.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE(:OLD.EMP_ID);
    DBMS_OUTPUT.PUT_LINE(:OLD.EMP_NAME);
    --DBMS_OUTPUT.PUT_LINE('신입이 등록되었습니다.');
END;
/

INSERT INTO EMPLOYEE VALUES (908, '길성춘', '690512-1151432','gil_sj@kh.or.kr', 
                    '01035464455', 'D5', 'J3', 'S5', 3000000, 0.1, 200, SYSDATE, NULL,
			       DEFAULT);

-- 트리거 속성
-- 1. 실행시점 : BEFORE / AFTER
-- 2. 실행시키는 명령 : INSERT, UPDATE, DELETE
-- 3. FOR EACH ROW : 각행마다 트리거를 발동
-- 4. 기존값, 신규값 가져오기
--    OLD. : 수정되기 전 값  NEW. : 수정 후 추가되는 값

CREATE OR REPLACE TRIGGER TRG_02
AFTER UPDATE
ON EMPLOYEE
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:OLD.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE(:OLD.SALARY);
    DBMS_OUTPUT.PUT_LINE(:NEW.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE(:NEW.SALARY);
END;
/
UPDATE EMPLOYEE SET EMP_NAME='박찬혁', SALARY=200 WHERE EMP_ID='906';


SELECT * FROM EMPLOYEE;


-- 재고관리 테이블에 트리거 적용하기
CREATE TABLE PRODUCT(
    PCODE NUMBER PRIMARY KEY,
    PNAME VARCHAR2(30),
    BRAND VARCHAR2(30),
    PRICE NUMBER,
    STOCK NUMBER DEFAULT 0
);
-- 상품에 대한 입출고을 관리하는 테이블
CREATE TABLE PRODUCT_IO(
    IOCODE NUMBER PRIMARY KEY,
    PCODE NUMBER CONSTRAINT FK_PIO_PCODE REFERENCES PRODUCT(PCODE),
    PDATE DATE,
    AMOUNT NUMBER,
    STATUS VARCHAR2(10) CHECK(STATUS IN ('입고','출고'))
);
DROP TABLE PRODUCT_IO;

CREATE SEQUENCE SEQ_PCODE;
CREATE SEQUENCE SEQ_IOCODE;

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_IO;

INSERT INTO PRODUCT VALUES(SEQ_PCODE.NEXTVAL,'갤럭시20','삼성',1200000,DEFAULT);
INSERT INTO PRODUCT VALUES(SEQ_PCODE.NEXTVAL,'애플미니홈','애플',120000,DEFAULT);
INSERT INTO PRODUCT VALUES(SEQ_PCODE.NEXTVAL,'E-CLASS','벤츠',120000000,DEFAULT);

SELECT * FROM PRODUCT;

CREATE TRIGGER PRODUCT_TRG
AFTER INSERT
ON PRODUCT_IO
FOR EACH ROW
BEGIN
    IF :NEW.STATUS = '입고' THEN
        UPDATE PRODUCT SET STOCK=STOCK+:NEW.AMOUNT WHERE PCODE=:NEW.PCODE;
    ELSIF :NEW.STATUS = '출고' THEN
        UPDATE PRODUCT SET STOCK=STOCK-:NEW.AMOUNT WHERE PCODE=:NEW.PCODE;
    END IF;
END;
/
SELECT * FROM PRODUCT;

INSERT INTO PRODUCT_IO VALUES(SEQ_IOCODE.NEXTVAL,1,SYSDATE,10,'입고');
INSERT INTO PRODUCT_IO VALUES(SEQ_IOCODE.NEXTVAL,3,SYSDATE,5,'입고');
INSERT INTO PRODUCT_IO VALUES(SEQ_IOCODE.NEXTVAL,1,SYSDATE,3,'출고');
SELECT * FROM PRODUCT_IO;

----- 끝!!!! -----










